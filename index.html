<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Gesture Xmas Tree Bright</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 15px; box-sizing: border-box;
            z-index: 10;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.4) 100%); /* è½»å¾®æš—è§’å¢å¼ºå¯¹æ¯” */
        }
        h1 { margin: 0; font-weight: 300; text-transform: uppercase; font-size: 18px; color: #FFD700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        .status-badge {
            display: inline-block; padding: 4px 10px; border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px; margin-top: 5px; background: rgba(0,0,0,0.6); color: #fff; font-size: 10px;
        }
        #upload-btn {
            background: rgba(255, 215, 0, 0.2); border: 1px solid rgba(255, 215, 0, 0.7);
            color: #FFD700; padding: 12px 25px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 12px; border-radius: 8px; backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #FFD700; flex-direction: column; transition: opacity 0.5s; padding: 20px; text-align: center;
        }
        .spinner {
            width: 30px; height: 30px; border: 2px solid #333; border-top: 2px solid #FFD700;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #guide {
            position: absolute; bottom: 20px; right: 15px; text-align: right;
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; pointer-events: none;
        }
        .guide-item { margin: 3px 0; font-size: 11px; color: #ccc; }
        .key { color: #FFD700; font-weight: bold; margin-right: 4px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline></video>
    <div id="loader">
        <div class="spinner"></div><div>æ­£åœ¨ç‚¹äº®åœ£è¯æ ‘...</div>
        <div style="font-size: 12px; color: #888; margin-top: 10px;">è¯·å…è®¸æ‘„åƒå¤´æˆ–åŒå‡»å±å¹•</div>
    </div>
    <div id="ui-layer">
        <div>
            <h1>Xmas Magic</h1>
            <div class="status-badge" id="status-display">INIT...</div>
            <br><br>
            <label for="file-input" id="upload-btn">ğŸ“· æ·»åŠ ç…§ç‰‡è£…é¥°</label>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </div>
        <div id="guide">
            <div class="guide-item"><span class="key">âœŠ</span> æ¡æ‹³: èšåˆ</div>
            <div class="guide-item"><span class="key">ğŸ–</span> å¼ æ‰‹: æ•£å¼€</div>
            <div class="guide-item"><span class="key">ğŸ‘†</span> åŒå‡»: åˆ‡æ¢æ¨¡å¼</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            colors: { gold: 0xFFBB00, red: 0xFF0000, green: 0x006400 }, // è°ƒæ•´äº†é‡‘è‰²ä½¿å…¶æ›´æš–
            particleCount: 380, treeHeight: 28, treeRadius: 11, scatterRadius: 35
        };

        let scene, camera, renderer, composer;
        let particles = []; let photoParticles = []; let time = 0;
        let currentState = 'TREE'; let targetRotationY = 0; let activePhotoIndex = -1;
        const worldGroup = new THREE.Group();
        let touchStartX = 0; let isTouching = false;

        async function init() {
            scene = new THREE.Scene();
            // ### æ ¸å¿ƒä¿®æ”¹1ï¼šé™ä½é›¾æ°”æµ“åº¦ï¼Œè®©è¿œå¤„æ›´æ¸…æ™° ###
            scene.fog = new THREE.FogExp2(0x020205, 0.015); 
            
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 4, 32); // ç¨å¾®é™ä½è§†è§’ä»°æ‹ï¼Œæ›´æ˜¾é«˜å¤§

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // ### æ ¸å¿ƒä¿®æ”¹2ï¼šä½¿ç”¨ ACESFilmic è‰²è°ƒæ˜ å°„ï¼Œå¤„ç†é«˜å…‰æ›´å¥½çœ‹ ###
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // æ•´ä½“æ›å…‰åº¦æé«˜
            document.body.appendChild(renderer.domElement);
            scene.add(worldGroup);

            // ### æ ¸å¿ƒä¿®æ”¹3ï¼šå…¨é¢å¢å¼ºç¯å…‰ç³»ç»Ÿ ###
            // 1. æ›´äº®çš„ç¯å¢ƒå…‰ (æš–ç™½è‰²)
            const ambientLight = new THREE.AmbientLight(0xffeedd, 2.5);
            scene.add(ambientLight);
            
            // 2. ä¸»å…‰æº (é‡‘è‰²ï¼Œäº®åº¦æé«˜ï¼Œä½ç½®æ›´é«˜æ›´è¿œ)
            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 4.0, 120);
            pointLight.position.set(5, 20, 20);
            scene.add(pointLight);
            
            // 3. æ–°å¢ï¼šä¾§é¢è¡¥å…‰ (å†·è‰²è°ƒï¼Œå¢åŠ ç«‹ä½“æ„Ÿ)
            const fillLight = new THREE.DirectionalLight(0xccccff, 1.5);
            fillLight.position.set(-20, 10, 10);
            scene.add(fillLight);

            // ### æ ¸å¿ƒä¿®æ”¹4ï¼šè°ƒæ•´è¾‰å…‰å‚æ•°ï¼Œæ›´å®¹æ˜“è§¦å‘å‘å…‰æ•ˆæœ ###
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; // é™ä½é—¨æ§›ï¼Œè®©æ›´å¤šç‰©ä½“å‘å…‰
            bloomPass.strength = 1.3;  // å¢åŠ å¼ºåº¦
            bloomPass.radius = 0.6;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createDecorations();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);
            setupTouchEvents();
            setupMediaPipe();
            animate();
        }

        function setupTouchEvents() {
            document.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; isTouching = true; }, {passive: false});
            document.addEventListener('touchmove', (e) => {
                if (!isTouching) return;
                const diffX = e.touches[0].clientX - touchStartX;
                if (currentState === 'SCATTERED') worldGroup.rotation.y += diffX * 0.005;
                touchStartX = e.touches[0].clientX;
                if(e.cancelable) e.preventDefault(); 
            }, {passive: false});
            document.addEventListener('touchend', () => { isTouching = false; });
            let lastTap = 0;
            document.addEventListener('click', (e) => {
                const currentTime = new Date().getTime();
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'LABEL') {
                    if (currentTime - lastTap < 500 && currentTime - lastTap > 0) toggleState();
                }
                lastTap = currentTime;
            });
        }

        function toggleState() {
            if(currentState === 'TREE') switchState('SCATTERED'); else switchState('TREE');
        }

        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh; this.type = type;
                this.scatterPos = new THREE.Vector3((Math.random()-0.5)*CONFIG.scatterRadius*2, (Math.random()-0.5)*CONFIG.scatterRadius*2, (Math.random()-0.5)*CONFIG.scatterRadius*2);
                this.treePos = new THREE.Vector3(); this.originalScale = mesh.scale.clone(); this.floatOffset = Math.random()*100;
            }
            update(currentState, time) {
                this.mesh.rotation.x += 0.01; this.mesh.rotation.y += 0.01;
                if (currentState === 'SCATTERED') this.mesh.position.y += Math.sin(time*2 + this.floatOffset)*0.015;
            }
        }

        function createDecorations() {
            // ### æ ¸å¿ƒä¿®æ”¹5ï¼šæè´¨å¢åŠ è‡ªå‘å…‰ (Emissive) ###
            // é‡‘è‰²ï¼šé«˜åå°„ + è‡ªèº«å‘å¾®å…‰
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, metalness: 0.8, roughness: 0.2,
                emissive: CONFIG.colors.gold, emissiveIntensity: 0.4
            });
            // çº¢è‰²ï¼šè‡ªèº«å‘çº¢å…‰
            const redMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, metalness: 0.3, roughness: 0.4,
                emissive: CONFIG.colors.red, emissiveIntensity: 0.5
            });
            // ç»¿è‰²ï¼šå“‘å…‰ï¼Œè½»å¾®å‘å…‰
            const greenMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, metalness: 0.1, roughness: 0.8,
                emissive: CONFIG.colors.green, emissiveIntensity: 0.2
            });

            const geoms = [
                { geo: new THREE.SphereGeometry(0.6, 24, 24), mat: goldMat },
                { geo: new THREE.BoxGeometry(0.8, 0.8, 0.8), mat: redMat },
                { geo: new THREE.IcosahedronGeometry(0.7, 1), mat: greenMat }
            ];

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const choice = geoms[Math.floor(Math.random() * geoms.length)];
                const mesh = new THREE.Mesh(choice.geo, choice.mat);
                const angle = i * 0.65;
                const y = (i / CONFIG.particleCount) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const currentRadius = CONFIG.treeRadius * (1 - progress * 0.8);
                mesh.position.set(Math.cos(angle) * currentRadius, y, Math.sin(angle) * currentRadius);
                worldGroup.add(mesh);
                const p = new Particle(mesh, 'decoration'); p.treePos.copy(mesh.position); particles.push(p);
            }

            // å¢åŠ ä¸€ä¸ªé¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(1.8, 0);
            const starMat = new THREE.MeshStandardMaterial({color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 1});
            const starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, CONFIG.treeHeight/2 + 1.5, 0);
            worldGroup.add(starMesh);
            const starP = new Particle(starMesh, 'star'); starP.treePos.copy(starMesh.position); particles.push(starP);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 5).forEach((file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace; // ç¡®ä¿ç…§ç‰‡é¢œè‰²æ­£ç¡®
                        const aspectRatio = texture.image.width / texture.image.height;
                        const geometry = new THREE.PlaneGeometry(4 * aspectRatio, 4);
                        // ç…§ç‰‡ä¹Ÿå¢åŠ ä¸€ç‚¹ç‚¹è‡ªå‘å…‰ï¼Œé˜²æ­¢å¤ªæš—
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
                        const mesh = new THREE.Mesh(geometry, material);
                        const y = (Math.random() * CONFIG.treeHeight * 0.8) - (CONFIG.treeHeight/2.5);
                        const angle = Math.random() * Math.PI * 2;
                        const radius = CONFIG.treeRadius + 2;
                        mesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                        mesh.lookAt(0, y, 0); mesh.rotateY(Math.PI);
                        worldGroup.add(mesh);
                        const p = new Particle(mesh, 'photo'); p.treePos.copy(mesh.position); particles.push(p); photoParticles.push(p);
                        if(currentState === 'TREE') toTreeState();
                    });
                };
                reader.readAsDataURL(file);
            });
            document.getElementById('status-display').innerText = "âœ¨ç…§ç‰‡å·²ä¸Šæ ‘";
        }

        function switchState(newState) {
            if (currentState === newState) return;
            currentState = newState;
            document.getElementById('status-display').innerText = `æ¨¡å¼: ${currentState === 'TREE' ? 'ğŸ„ åœ£è¯æ ‘' : 'âœ¨ æ˜Ÿäº‘æ•£å¼€'}`;
            if (currentState === 'TREE') toTreeState();
            else if (currentState === 'SCATTERED') toScatteredState();
        }

        function toTreeState() {
            gsap.to(camera.position, { duration: 1.5, z: 32, y: 4, ease: "power2.inOut" });
            particles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 1.8, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, ease: "elastic.out(0.8, 0.5)" });
                gsap.to(p.mesh.rotation, { duration: 1.5, x: p.type==='photo'?0:p.mesh.rotation.x, y: p.type==='photo'?Math.atan2(p.treePos.x, p.treePos.z)+Math.PI:p.mesh.rotation.y, z: 0 });
                if(p.type==='photo') gsap.to(p.mesh.scale, {duration: 1, x:1, y:1, z:1});
            });
        }

        function toScatteredState() {
            particles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 2.2, x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z, ease: "power3.out" });
                gsap.to(p.mesh.rotation, { duration: 2, x: Math.random()*6, y: Math.random()*6, z: Math.random()*6 });
            });
        }

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 480, height: 640, facingMode: 'user'
            });
            cameraUtils.start().then(() => { document.getElementById('loader').style.display = 'none'; })
                .catch(err => { console.error(err); document.getElementById('loader').innerHTML = "æ‘„åƒå¤´å¤±è´¥<br>è¯·åŒå‡»å±å¹•æ“ä½œ"; setTimeout(()=>document.getElementById('loader').style.display='none',3000); });
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detectGesture(results.multiHandLandmarks[0]);
            }
        }

        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            let avgDist = 0;
            [8, 12, 16, 20].forEach(idx => { avgDist += Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2)); });
            avgDist /= 4;
            if (currentState === 'SCATTERED') targetRotationY = (0.5 - landmarks[9].x) * 4;
            if (avgDist < 0.18) { if(currentState !== 'TREE') switchState('TREE'); }
            else if (avgDist > 0.38) { if(currentState !== 'SCATTERED') switchState('SCATTERED'); }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate); time += 0.01;
            if (currentState === 'SCATTERED') worldGroup.rotation.y += (targetRotationY - worldGroup.rotation.y) * 0.04;
            else worldGroup.rotation.y += 0.002;
            particles.forEach(p => p.update(currentState, time));
            composer.render();
        }

        init();
    </script>
</body>
</html>
