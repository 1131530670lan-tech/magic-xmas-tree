<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exquisite Xmas Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
        /* å¾®å¦™çš„èƒŒæ™¯æ¸å˜ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ */
        body { background: radial-gradient(circle at 50% 30%, #1a1a2e 0%, #000000 70%); }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
            z-index: 10;
        }
        h1 { margin: 0; font-weight: 200; text-transform: uppercase; font-size: 20px; color: #d4af37; letter-spacing: 2px; text-shadow: 0 2px 10px rgba(212, 175, 55, 0.3); }
        .status-badge {
            display: inline-block; padding: 4px 12px; border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 20px; margin-top: 8px; background: rgba(0,0,0,0.5); color: #d4af37; font-size: 11px;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }
        #upload-btn {
            background: linear-gradient(45deg, rgba(212, 175, 55, 0.2), rgba(212, 175, 55, 0.1));
            border: 1px solid rgba(212, 175, 55, 0.5); color: #d4af37; padding: 12px 24px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 12px; border-radius: 30px; backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); transition: all 0.3s; display: inline-flex; align-items: center;
        }
        #upload-btn span { margin-left: 8px; }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 0.8s ease-out; padding: 20px; text-align: center;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37;
            border-radius: 50%; animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite; margin-bottom: 25px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #guide {
            position: absolute; bottom: 25px; right: 20px; text-align: right;
            background: rgba(0,0,0,0.4); padding: 15px; border-radius: 12px; pointer-events: none;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.05);
        }
        .guide-item { margin: 5px 0; font-size: 11px; color: rgba(255,255,255,0.7); display: flex; align-items: center; justify-content: flex-end; }
        .key { color: #d4af37; font-weight: 600; margin-right: 8px; font-size: 14px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    <div id="loader">
        <div class="spinner"></div>
        <div style="letter-spacing: 1px;">æ­£åœ¨æ„ç­‘èŠ‚æ—¥é­”æ³•...</div>
        <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 15px; line-height: 1.6;">ä¸ºäº†æœ€ä½³ä½“éªŒï¼Œè¯·å…è®¸æ‘„åƒå¤´æƒé™<br>æ‰‹åŠ¿è¯†åˆ«è®¡ç®—åœ¨æœ¬åœ°è¿è¡Œ</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>LumiÃ¨re NoÃ«l</h1>
            <div class="status-badge" id="status-display">ç­‰å¾…æŒ‡ä»¤...</div>
            <br><br><br>
            <label for="file-input" id="upload-btn">ğŸ“· <span>è£…é¥°ç…§ç‰‡å›å¿†</span></label>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </div>
        
        <div id="guide">
            <div class="guide-item"><span class="key">âœŠ</span> æ¡æ‹³ Â· èšåˆåœ£è¯æ ‘</div>
            <div class="guide-item"><span class="key">ğŸ–</span> å¼ æ‰‹ Â· æ•£å¼€æ˜Ÿäº‘</div>
            <div class="guide-item" id="pinch-guide" style="display:none; opacity: 0.6;"><span class="key">ğŸ‘Œ</span> æåˆ Â· è¿›å…¥ç…§ç‰‡è‰ºå»Š</div>
            <div class="guide-item"><span class="key">â†”ï¸</span> æŒ¥æ‰‹/æ»‘åŠ¨ Â· æ—‹è½¬è§†è§’</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½® ---
        const CONFIG = {
            // ä½¿ç”¨æ›´é«˜çº§çš„é‡‘è‰²å’Œæ·±çº¢è‰²
            colors: { gold: 0xd4af37, red: 0x8a1a1a, green: 0x0a3a1a, gem: 0x00ff88 },
            particleCount: 300, // ç¨å¾®å‡å°‘æ•°é‡ï¼Œæé«˜å•ä¸ªè´¨é‡
            treeHeight: 28,
            treeRadius: 10,
            scatterRadius: 40,
            carouselRadius: 18 // ç…§ç‰‡è‰ºå»Šçš„åŠå¾„
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let particles = []; 
        let photoParticles = [];
        let time = 0;
        // çŠ¶æ€: TREE (æ ‘), SCATTERED (æ•£å¼€), CAROUSEL (ç…§ç‰‡è½®æ’­)
        let currentState = 'TREE'; 
        let targetRotationY = 0;
        let carouselRotation = 0; // è½®æ’­å›¾çš„æ—‹è½¬è§’åº¦
        
        const worldGroup = new THREE.Group();
        const photoGroup = new THREE.Group(); // ä¸“é—¨æ”¾ç…§ç‰‡çš„ç»„ï¼Œæ–¹ä¾¿å•ç‹¬æ§åˆ¶
        worldGroup.add(photoGroup);

        // è§¦æ‘¸å˜é‡
        let touchStartX = 0; let isTouching = false;

        // --- åˆå§‹åŒ– ---
        async function init() {
            scene = new THREE.Scene();
            // ä½¿ç”¨ææ·¡çš„è“è‰²é›¾æ°”ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿï¼Œè€Œä¸æ˜¯é»‘è‰²æ­»é›¾
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.012);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 35);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance", stencil: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // ä½¿ç”¨ç”µå½±çº§è‰²è°ƒæ˜ å°„
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            setupLighting();
            setupPostProcessing();
            createExquisiteDecorations();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupTouchEvents(); // ä»…ä¿ç•™æ»‘åŠ¨ï¼Œç§»é™¤äº†åŒå‡»
            setupMediaPipe();
            animate();
        }

        // --- ç²¾è‡´çš„ç¯å…‰ç³»ç»Ÿ ---
        function setupLighting() {
            // 1. ç¯å¢ƒå…‰ï¼šæš–è‰²è°ƒï¼Œæä¾›åŸºç¡€ç…§æ˜
            const ambientLight = new THREE.AmbientLight(0xffecd1, 1.5);
            scene.add(ambientLight);

            // 2. ä¸»å…‰æºï¼šé‡‘è‰²ç‚¹å…‰ï¼Œæ¨¡æ‹Ÿæ ‘é¡¶æ˜Ÿå…‰ç…§äº®ä¸‹æ–¹
            const mainLight = new THREE.PointLight(CONFIG.colors.gold, 8, 150);
            mainLight.position.set(0, 25, 10);
            mainLight.decay = 2;
            scene.add(mainLight);
            
            // 3. ä¾§é¢è¡¥å…‰ï¼šå†·è‰²è°ƒï¼Œå‹¾å‹’è¾¹ç¼˜è½®å»“ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
            const rimLight = new THREE.DirectionalLight(0xccccff, 3);
            rimLight.position.set(-20, 10, -20);
            scene.add(rimLight);

            // 4. åº•éƒ¨è¡¥å…‰ï¼šæš–çº¢è‰²ï¼Œç…§äº®åº•éƒ¨
            const bottomLight = new THREE.PointLight(CONFIG.colors.red, 3, 50);
            bottomLight.position.set(0, -15, 5);
            scene.add(bottomLight);
        }

        // --- åå¤„ç† (è¾‰å…‰) ---
        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            // å‚æ•°è°ƒæ•™ï¼šæ›´æŸ”å’Œã€æ›´æ‰©æ•£çš„å…‰æ™•ï¼Œé¿å…åˆºçœ¼
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // æé«˜é—¨æ§›ï¼Œåªè®©äº®éƒ¨å‘å…‰
            bloomPass.strength = 1.2;  // å¼ºåº¦é€‚ä¸­
            bloomPass.radius = 0.8;    // åŠå¾„æ›´å¤§ï¼Œæ›´æŸ”å’Œ
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // --- è§¦æ‘¸äº¤äº’ (ä»…ä¿ç•™æ»‘åŠ¨) ---
        function setupTouchEvents() {
            document.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; isTouching = true; }, {passive: false});
            document.addEventListener('touchmove', (e) => {
                if (!isTouching) return;
                const diffX = e.touches[0].clientX - touchStartX;
                // æ ¹æ®çŠ¶æ€å†³å®šæ»‘åŠ¨æ˜¯æ—‹è½¬æ•´ä½“è¿˜æ˜¯æ—‹è½¬ç…§ç‰‡å¢™
                if (currentState === 'CAROUSEL') {
                    carouselRotation += diffX * 0.008;
                } else if (currentState === 'SCATTERED') {
                    worldGroup.rotation.y += diffX * 0.005;
                }
                touchStartX = e.touches[0].clientX;
                if(e.cancelable) e.preventDefault(); 
            }, {passive: false});
            document.addEventListener('touchend', () => { isTouching = false; });
            // å·²ç§»é™¤ click äº‹ä»¶ç›‘å¬å™¨
        }

        // --- ç²’å­åŸºç±» ---
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh;
                this.type = type;
                // æ•£å¼€ä½ç½®
                this.scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.scatterRadius * 2,
                    (Math.random() - 0.5) * CONFIG.scatterRadius * 2.5, // Yè½´æ‹‰ä¼¸ä¸€ç‚¹
                    (Math.random() - 0.5) * CONFIG.scatterRadius * 2
                );
                this.treePos = new THREE.Vector3();
                this.carouselPos = new THREE.Vector3(); // ç…§ç‰‡è‰ºå»Šä½ç½®
                this.carouselAngle = 0; // åœ¨è‰ºå»Šä¸­çš„è§’åº¦
                
                this.originalScale = mesh.scale.clone();
                // éšæœºè‡ªè½¬é€Ÿåº¦
                this.rotSpeed = { x: Math.random()*0.01, y: Math.random()*0.01, z: Math.random()*0.01 };
                this.floatOffset = Math.random() * 100;
            }

            update(currentState, time) {
                // æŒç»­ç¼“æ…¢è‡ªè½¬ï¼Œå¢åŠ åŠ¨æ„Ÿ
                if (this.type !== 'photo') {
                    this.mesh.rotation.x += this.rotSpeed.x;
                    this.mesh.rotation.y += this.rotSpeed.y;
                    this.mesh.rotation.z += this.rotSpeed.z;
                }
                // æ•£å¼€çŠ¶æ€ä¸‹çš„è½»å¾®æµ®åŠ¨
                if (currentState === 'SCATTERED') {
                    this.mesh.position.y += Math.sin(time * 1.5 + this.floatOffset) * 0.02;
                }
            }
        }

        // --- åˆ›å»ºç²¾è‡´è£…é¥°å“ ---
        function createExquisiteDecorations() {
            // 1. åä¸½çš„é‡‘çƒæè´¨ (é«˜é‡‘å±æ„Ÿï¼Œé«˜åå°„)
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 0.9, roughness: 0.1, // å…‰æ»‘é‡‘å±
                emissive: CONFIG.colors.gold, emissiveIntensity: 0.2, // è½»å¾®è‡ªå‘å…‰
                envMapIntensity: 1.5 
            });

            // 2. å“‘å…‰çº¢çƒå¸¦é‡‘è¾¹æè´¨ (ä½¿ç”¨ä¸åŒæè´¨ç»„åˆ)
            const redMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                metalness: 0.2, roughness: 0.7, // å“‘å…‰
                emissive: CONFIG.colors.red, emissiveIntensity: 0.4
            });
            const redGoldTrimMat = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, metalness: 1, roughness: 0});

            // 3. å®çŸ³æè´¨ (é€æ˜ã€é«˜æŠ˜å°„)
            const gemMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.gem, metalness: 0, roughness: 0,
                transmission: 0.9, opacity: 1, transparent: true, // é€æ˜
                ior: 2.4, // é«˜æŠ˜å°„ç‡ï¼Œåƒé’»çŸ³
                emissive: CONFIG.colors.gem, emissiveIntensity: 0.5,
                thickness: 1.0
            });

            // å‡ ä½•ä½“ç”Ÿæˆ
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh, type;
                const rand = Math.random();
                
                if (rand < 0.5) {
                    // 50% é‡‘çƒ (é«˜ç²¾åº¦çƒä½“)
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 32), goldMat);
                    type = 'gold_orb';
                } else if (rand < 0.85) {
                    // 35% çº¢çƒå¸¦é‡‘ç¯ (ç»„åˆç½‘æ ¼)
                    mesh = new THREE.Group();
                    const redBall = new THREE.Mesh(new THREE.SphereGeometry(0.7, 24, 24), redMat);
                    const goldRing = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.05, 16, 32), redGoldTrimMat);
                    goldRing.rotation.x = Math.PI / 2;
                    mesh.add(redBall); mesh.add(goldRing);
                    mesh.scale.setScalar(Math.random() * 0.3 + 0.8); // éšæœºå¤§å°
                    type = 'red_bauble';
                } else {
                    // 15% å®çŸ³ (äºŒåé¢ä½“ï¼Œæ£±è§’åˆ†æ˜)
                    mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), gemMat);
                    mesh.scale.setScalar(Math.random() * 0.4 + 0.8);
                    type = 'gem';
                }
                
                // åœ£è¯æ ‘èºæ—‹ä½ç½®è®¡ç®—
                const angle = i * 0.5; // èºæ—‹å¯†åº¦
                const y = (i / CONFIG.particleCount) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                // ä½¿ç”¨å¹‚å‡½æ•°è®©æ ‘å½¢åº•éƒ¨æ›´èƒ–ï¼Œé¡¶éƒ¨æ›´å°–
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const currentRadius = CONFIG.treeRadius * Math.pow(1 - progress, 0.8);

                const x = Math.cos(angle) * currentRadius;
                const z = Math.sin(angle) * currentRadius;

                mesh.position.set(x, y, z);
                // éšæœºåˆå§‹æ—‹è½¬
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                worldGroup.add(mesh);

                const p = new Particle(mesh, type);
                p.treePos.set(x, y, z);
                particles.push(p);
            }

            // é¡¶éƒ¨ä¼¯åˆ©æ’ä¹‹æ˜Ÿ (ç»„åˆä½“ï¼šæ ¸å¿ƒå‘å…‰çƒ + å¤–éƒ¨å°–åˆº)
            const starGroup = new THREE.Group();
            const starCore = new THREE.Mesh(
                new THREE.OctahedronGeometry(1, 2), 
                new THREE.MeshBasicMaterial({ color: 0xffffff }) // çº¯ç™½é«˜äº®ä¸­å¿ƒ
            );
            const starSpikes = new THREE.Mesh(
                new THREE.OctahedronGeometry(2.2, 0), 
                new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.1, emissive: CONFIG.colors.gold, emissiveIntensity: 1 })
            );
            starGroup.add(starCore); starGroup.add(starSpikes);
            starGroup.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            worldGroup.add(starGroup);
            
            const starP = new Particle(starGroup, 'star');
            starP.treePos.copy(starGroup.position);
            // æ˜Ÿæ˜Ÿæ•£å¼€æ—¶ä¸è·‘å¤ªè¿œï¼Œä¿æŒåœ¨ä¸Šæ–¹
            starP.scatterPos.set(0, CONFIG.treeHeight/2 + 10, 0); 
            particles.push(starP);
        }

        // --- ç…§ç‰‡å¤„ç† ---
        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            
            // é™åˆ¶ç…§ç‰‡æ•°é‡ï¼Œé˜²æ­¢æ€§èƒ½é—®é¢˜
            Array.from(files).slice(0, 12).forEach((file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        // ç”Ÿæˆå¸¦é‡‘è¾¹çš„ç…§ç‰‡æ¡†
                        const aspectRatio = texture.image.width / texture.image.height;
                        const frameGeo = new THREE.BoxGeometry(3 * aspectRatio + 0.2, 3.2, 0.1); // æ¯”ç…§ç‰‡å¤§ä¸€ç‚¹çš„æ¡†
                        const photoGeo = new THREE.PlaneGeometry(3 * aspectRatio, 3);
                        
                        const frameMat = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, metalness: 0.9, roughness: 0.1});
                        const photoMat = new THREE.MeshBasicMaterial({ map: texture }); // ç…§ç‰‡æœ¬èº«ä¸éœ€è¦å…‰ç…§è®¡ç®—

                        const frameMesh = new THREE.Mesh(frameGeo, frameMat);
                        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                        photoMesh.position.z = 0.06; // ç¨å¾®å‡¸å‡ºä¸€ç‚¹
                        
                        const combinedMesh = new THREE.Group();
                        combinedMesh.add(frameMesh); combinedMesh.add(photoMesh);

                        // åˆå§‹éšæœºä½ç½®æ’å…¥æ ‘ä¸­
                        const y = (Math.random() * CONFIG.treeHeight * 0.7) - (CONFIG.treeHeight/3);
                        const angle = Math.random() * Math.PI * 2;
                        const radius = CONFIG.treeRadius * (1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 2; // åœ¨æ ‘è¡¨é¢
                        combinedMesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                        combinedMesh.lookAt(0, y, 0); // é¢å‘ä¸­å¿ƒ
                        
                        photoGroup.add(combinedMesh);
                        
                        const p = new Particle(combinedMesh, 'photo');
                        p.treePos.copy(combinedMesh.position);
                        particles.push(p);
                        photoParticles.push(p);
                        
                        // å¦‚æœæœ‰ç…§ç‰‡äº†ï¼Œæ˜¾ç¤ºæåˆæ‰‹åŠ¿æç¤º
                        document.getElementById('pinch-guide').style.display = 'flex';
                        
                        if(currentState === 'TREE') toTreeState();
                    });
                };
                reader.readAsDataURL(file);
            });
            document.getElementById('status-display').innerText = "ç…§ç‰‡å·²è½¬åŒ–ä¸ºè®°å¿†æ°´æ™¶";
        }

        // --- çŠ¶æ€åˆ‡æ¢ä¸åŠ¨ç”» (GSAP) ---
        function switchState(newState) {
            if (currentState === newState) return;
            
            // å¦‚æœè¦è¿›å…¥è‰ºå»Šæ¨¡å¼ä½†æ²¡ç…§ç‰‡ï¼Œé˜»æ­¢
            if (newState === 'CAROUSEL' && photoParticles.length === 0) {
                 document.getElementById('status-display').innerText = "è¯·å…ˆæ·»åŠ ç…§ç‰‡";
                 setTimeout(() => document.getElementById('status-display').innerText = "æ¨¡å¼: æ•£å¼€", 1500);
                 return;
            }

            currentState = newState;
            let statusText = "";
            if (currentState === 'TREE') statusText = "ğŸ„ åœ£è¯æ ‘å½¢æ€";
            else if (currentState === 'SCATTERED') statusText = "âœ¨ æ˜Ÿäº‘æ•£å¼€å½¢æ€";
            else if (currentState === 'CAROUSEL') statusText = "ğŸ–¼ï¸ ç…§ç‰‡è‰ºå»Š (æŒ¥æ‰‹æ»‘åŠ¨)";
            document.getElementById('status-display').innerText = `æ¨¡å¼: ${statusText}`;

            if (currentState === 'TREE') toTreeState();
            else if (currentState === 'SCATTERED') toScatteredState();
            else if (currentState === 'CAROUSEL') toCarouselState();
        }

        function toTreeState() {
            // ç›¸æœºå¤ä½
            gsap.to(camera.position, { duration: 1.5, x: 0, y: 2, z: 35, ease: "power2.inOut" });
            gsap.to(worldGroup.rotation, { duration: 1.5, x: 0, z: 0, ease: "power2.inOut" }); // Yè½´ç•™ç»™è‡ªåŠ¨æ—‹è½¬

            particles.forEach(p => {
                // ä½ç½®å›å½’
                gsap.to(p.mesh.position, { 
                    duration: 1.5 + Math.random(), 
                    x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, 
                    ease: "elastic.out(0.8, 0.6)" // å¼¹æ€§æ•ˆæœ
                });
                // æ—‹è½¬å›å½’ (ç…§ç‰‡é¢å‘å¤–ï¼Œè£…é¥°å“éšæœº)
                if (p.type === 'photo') {
                    gsap.to(p.mesh.rotation, { duration: 1.2, x: 0, y: Math.atan2(p.treePos.x, p.treePos.z), z: 0 });
                }
                gsap.to(p.mesh.scale, { duration: 1, x: p.originalScale.x, y: p.originalScale.y, z: p.originalScale.z });
            });
        }

        function toScatteredState() {
             // ç›¸æœºç¨å¾®æ‹‰è¿œï¼Œçœ‹æ•´ä½“
            gsap.to(camera.position, { duration: 2, z: 45, ease: "power2.out" });
            
            particles.forEach(p => {
                gsap.to(p.mesh.position, { 
                    duration: 2.5 + Math.random(), 
                    x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z, 
                    ease: "power3.out" // ç¼“æ…¢å‡é€Ÿ
                });
                // éšæœºæ—‹è½¬
                gsap.to(p.mesh.rotation, { 
                    duration: 2.5, 
                    x: Math.random()*Math.PI*2, y: Math.random()*Math.PI*2, z: Math.random()*Math.PI*2 
                });
                 gsap.to(p.mesh.scale, { duration: 1, x: p.originalScale.x, y: p.originalScale.y, z: p.originalScale.z });
            });
        }
        
        // æ–°å¢ï¼šç…§ç‰‡è‰ºå»ŠçŠ¶æ€
        function toCarouselState() {
            // 1. è®¡ç®—ç…§ç‰‡åœ¨ç¯å½¢è‰ºå»Šä¸­çš„ä½ç½®
            const count = photoParticles.length;
            const angleStep = (Math.PI * 2) / count;
            photoParticles.forEach((p, index) => {
                const angle = index * angleStep;
                p.carouselAngle = angle; // å­˜ä¸‹æ¥ç”¨äºåç»­æ—‹è½¬è®¡ç®—
                p.carouselPos.set(
                    Math.cos(angle) * CONFIG.carouselRadius,
                    0, // åœ¨åŒä¸€æ°´å¹³é¢
                    Math.sin(angle) * CONFIG.carouselRadius
                );
            });

            // 2. åŠ¨ç”»ï¼šè£…é¥°å“æ•£å¼€é€€åï¼Œç…§ç‰‡é£åˆ°å‰æ™¯æ’é˜Ÿ
            particles.forEach(p => {
                if (p.type === 'photo') {
                    // ç…§ç‰‡é£åˆ°è‰ºå»Šä½ç½®
                    gsap.to(p.mesh.position, { duration: 1.5, x: p.carouselPos.x, y: p.carouselPos.y, z: p.carouselPos.z, ease: "power2.out" });
                    // ç…§ç‰‡é¢å‘åœ†å¿ƒ(ç›¸æœº)
                    gsap.to(p.mesh.rotation, { duration: 1.5, x: 0, y: Math.atan2(p.carouselPos.x, p.carouselPos.z) + Math.PI, z: 0 });
                    // ç¨å¾®æ”¾å¤§ç…§ç‰‡
                    gsap.to(p.mesh.scale, { duration: 1, x: 1.2, y: 1.2, z: 1.2 });
                } else {
                    // å…¶ä»–è£…é¥°å“æ¨åˆ°æ›´è¿œçš„åœ°æ–¹åšèƒŒæ™¯
                    gsap.to(p.mesh.position, { 
                        duration: 2, 
                        x: p.scatterPos.x * 1.5, y: p.scatterPos.y * 1.5, z: p.scatterPos.z * 1.5, 
                        ease: "power2.inOut" 
                    });
                }
            });
            
            // é‡ç½®è½®æ’­è§’åº¦
            carouselRotation = 0;
            // ç›¸æœºè°ƒæ•´åˆ°å¹³è§†
            gsap.to(camera.position, { duration: 1.5, x: 0, y: 0, z: 30, ease: "power2.inOut" });
            gsap.to(worldGroup.rotation, { duration: 1.5, x: 0, y: 0, z: 0 });
        }


        // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« (æ ¸å¿ƒäº¤äº’) ---
        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            // ä½¿ç”¨ Lite æ¨¡å‹ä¿è¯æ‰‹æœºæµç•…åº¦
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 480, height: 640, facingMode: 'user' // å¼ºåˆ¶å‰ç½®ä¸”ä½åˆ†è¾¨ç‡
            });
            cameraUtils.start()
                .then(() => { 
                    // æˆåŠŸå¯åŠ¨ï¼Œéšè—åŠ è½½å±‚
                    gsap.to('#loader', { duration: 0.8, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' });
                })
                .catch(err => { 
                    console.error(err); 
                    document.getElementById('loader').innerHTML = "<div style='color:#d4af37'>æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥HTTPSæˆ–æƒé™<br>åªèƒ½ä½¿ç”¨è§¦æ‘¸æ»‘åŠ¨</div>"; 
                    gsap.to('#loader', { delay: 3, duration: 0.8, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' });
                });
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGesture(landmarks);
            }
        }

        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            // 1. è®¡ç®—äº”æŒ‡å¼ å¼€ç¨‹åº¦ (æ¡æ‹³åˆ¤å®š)
            let avgDist = 0;
            [8, 12, 16, 20].forEach(idx => { 
                avgDist += Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2)); 
            });
            avgDist /= 4;

            // 2. è®¡ç®—æåˆè·ç¦» (é£ŸæŒ‡å’Œå¤§æ‹‡æŒ‡)
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

            // 3. è·å–æ‰‹æŒä¸­å¿ƒXåæ ‡ (ç”¨äºæ—‹è½¬æ§åˆ¶)
            // é•œåƒåè½¬ä¸€ä¸‹ï¼Œç¬¦åˆç›´è§‰
            const handX = 1.0 - landmarks[9].x; 

            // --- æ‰‹åŠ¿é€»è¾‘åˆ¤å®š ---
            
            // ä¼˜å…ˆçº§ 1: æ¡æ‹³ -> å˜æ ‘ (å…¨å±€å¤ä½)
            if (avgDist < 0.18) {
                 if(currentState !== 'TREE') switchState('TREE');
            } 
            // ä¼˜å…ˆçº§ 2: æåˆ -> è¿›å…¥ç…§ç‰‡è‰ºå»Š (å‰ææ˜¯æœ‰ç…§ç‰‡)
            else if (pinchDist < 0.06 && photoParticles.length > 0) {
                if (currentState !== 'CAROUSEL') switchState('CAROUSEL');
            }
            // ä¼˜å…ˆçº§ 3: å¼ å¼€æ‰‹ -> æ•£å¼€
            else if (avgDist > 0.35) {
                 if(currentState === 'TREE') switchState('SCATTERED');
            }

            // --- è¿ç»­æ§åˆ¶é€»è¾‘ (æ—‹è½¬) ---
            if (currentState === 'CAROUSEL') {
                // åœ¨è‰ºå»Šæ¨¡å¼ä¸‹ï¼Œæ‰‹çš„Xä½ç½®æ˜ å°„ä¸ºè½®æ’­å›¾çš„æ—‹è½¬ç›®æ ‡è§’åº¦
                // å°† 0.2~0.8 çš„èŒƒå›´æ˜ å°„åˆ° -PI~PI
                let mappedX = Math.max(0.2, Math.min(0.8, handX));
                targetRotationY = (mappedX - 0.5) * Math.PI * 4; // æ‰©å¤§æ—‹è½¬èŒƒå›´
            } 
            else if (currentState === 'SCATTERED') {
                // åœ¨æ•£å¼€æ¨¡å¼ä¸‹ï¼Œæ§åˆ¶æ•´ä½“åœºæ™¯æ—‹è½¬
                targetRotationY = (handX - 0.5) * 4;
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            // çŠ¶æ€ç›¸å…³çš„æ—‹è½¬é€»è¾‘
            if (currentState === 'CAROUSEL') {
                // å¹³æ»‘æ’å€¼æ—‹è½¬è§’åº¦
                carouselRotation += (targetRotationY - carouselRotation) * 0.05;
                // æ›´æ–°æ‰€æœ‰ç…§ç‰‡çš„ä½ç½®å’Œæœå‘
                photoParticles.forEach(p => {
                    const currentAngle = p.carouselAngle + carouselRotation;
                    p.mesh.position.x = Math.cos(currentAngle) * CONFIG.carouselRadius;
                    p.mesh.position.z = Math.sin(currentAngle) * CONFIG.carouselRadius;
                    // å§‹ç»ˆé¢å‘åœ†å¿ƒï¼Œä½†åœ¨ Y è½´ä¸ŠåŠ  PI (180åº¦) è®©æ­£é¢æœå¤–
                    p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                });
                // è‰ºå»Šæ¨¡å¼ä¸‹ï¼Œæ•´ä½“åœºæ™¯ç¼“æ…¢èƒŒæ™¯æ—‹è½¬
                worldGroup.rotation.y += 0.001;
            } else if (currentState === 'SCATTERED') {
                 // æ‰‹åŠ¿æ§åˆ¶æ•´ä½“æ—‹è½¬
                worldGroup.rotation.y += (targetRotationY - worldGroup.rotation.y) * 0.05;
            } else if (currentState === 'TREE') {
                // åœ£è¯æ ‘è‡ªåŠ¨ç¼“æ…¢è‡ªè½¬
                worldGroup.rotation.y += 0.002;
            }

            // æ›´æ–°ç²’å­é€šç”¨åŠ¨ç”» (è‡ªè½¬ã€æµ®åŠ¨)
            particles.forEach(p => p.update(currentState, time));

            // æ¸²æŸ“é€šé“
            composer.render();
        }

        init();
    </script>
</body>
</html>
