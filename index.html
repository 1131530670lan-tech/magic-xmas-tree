<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas Dream: Gallery Edition</title>
    <style>
        /* Ê∑±ÈÇÉÁ∫ØÈªëËÉåÊôØÔºåË°¨ÊâòÈáëËâ≤Á≤íÂ≠ê */
        body { margin: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box;
            z-index: 10; color: #fff;
        }
        
        h1 { 
            margin: 0 0 5px 0; font-weight: 400; text-transform: uppercase; 
            font-size: 24px; color: #f0e68c; letter-spacing: 4px; text-align: center;
            text-shadow: 0 0 20px rgba(240, 230, 140, 0.6);
        }
        
        .sub-controls { text-align: center; pointer-events: auto; }
        #upload-btn {
            background: rgba(0,0,0,0.5); border: 1px solid rgba(240, 230, 140, 0.4); 
            color: #f0e68c; padding: 8px 15px; cursor: pointer; 
            text-transform: uppercase; font-size: 10px; letter-spacing: 2px;
            transition: all 0.3s; display: inline-block; border-radius: 20px;
        }
        #upload-btn:active { background: rgba(240, 230, 140, 0.2); }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1s ease-out;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-family: sans-serif; font-size: 10px; color: rgba(255,255,255,0.4);
            letter-spacing: 1px; text-transform: uppercase; line-height: 1.5;
        }
        .key { color: #f0e68c; font-weight: bold; margin: 0 2px; }
        
        /* Áä∂ÊÄÅÊåáÁ§∫Âô® */
        #mode-indicator {
            position: absolute; top: 80px; width: 100%; text-align: center;
            font-size: 10px; color: rgba(240, 230, 140, 0.6); letter-spacing: 2px;
            opacity: 0; transition: opacity 0.5s;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    
    <div id="loader">
        <div style="letter-spacing: 3px; font-size: 14px;">LOADING MAGIC...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <div id="mode-indicator">TREE MODE</div>
            <div class="sub-controls">
                <label for="file-input" id="upload-btn">Add Photos</label>
                <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            </div>
        </div>
        
        <div id="guide">
            <span class="key">‚úä</span> Fist: Reset Tree<br>
            <span class="key">üëå</span> Pinch: Gallery ¬∑ <span class="key">üëê</span> Open Pinch: Zoom Photo
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 4500, // ‰øùÊåÅÂ•¢ÂçéÁöÑÁ≤íÂ≠êÊï∞Èáè
            treeHeight: 35,
            treeRadius: 12,
            scatterRadius: 55,
            carouselRadius: 18
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup;
        let photoParticles = [];
        let currentState = 'TREE'; // 'TREE', 'CAROUSEL', 'ZOOM'
        
        // Âä®ÁîªÂèòÈáè
        const animState = { transition: 0 }; 
        let carouselAngleOffset = 0; // ËΩÆÊí≠ÂõæÁöÑÊóãËΩ¨ËßíÂ∫¶
        let activePhotoIndex = 0;    // ÂΩìÂâçÈù¢ÂêëÁî®Êà∑ÁöÑÁÖßÁâáÁ¥¢Âºï

        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        worldGroup.add(photoGroup);

        // --- GLSL Shaders (‰øùÊåÅÊûÅÁπÅ‰∏ª‰πâËßÜËßâ) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState; // 0=Tree, 1=Scattered
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                vRandom = aRandom;
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                vPos = pos;
                
                // ÂëºÂê∏ÊïàÊûú
                float noise = sin(uTime * 1.5 + aRandom * 15.0) * 0.15;
                pos.x += noise * uState; 
                pos.y += noise * 0.3;
                pos.z += cos(uTime * 1.5 + aRandom * 15.0) * 0.15 * uState;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                float twinkle = sin(uTime * 3.0 + aRandom * 25.0) * 0.5 + 0.5;
                gl_PointSize = aSize * (220.0 / -mvPosition.z) * (0.4 + 0.6 * twinkle);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;
                float strength = pow(1.0 - dist * 2.0, 2.5);
                vec3 color = mix(uColor1, uColor2, vRandom);
                // Â∫ïÈÉ®ÂÅèÁ∫¢ÔºåÈ°∂ÈÉ®ÂÅè‰∫Æ
                color += vec3(0.15, 0.05, 0.0) * (vPos.y / 25.0);
                gl_FragColor = vec4(color * strength * 1.8, strength);
            }
        `;

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0500, 0.006); // ÈªëËâ≤ÂæÆÈáëÈõæ
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 45);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            setupLighting();
            setupPostProcessing();
            createParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupMediaPipe();
            animate();
        }

        function setupLighting() {
            const mainLight = new THREE.PointLight(0xffd700, 4, 100);
            mainLight.position.set(0, 15, 0);
            worldGroup.add(mainLight);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.8, 0.9);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const treePositions = new Float32Array(CONFIG.particleCount * 3);
            const scatterPositions = new Float32Array(CONFIG.particleCount * 3);
            const randoms = new Float32Array(CONFIG.particleCount);
            const sizes = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Tree
                const angle = i * 0.1 + Math.random() * 0.5;
                const y = (i / CONFIG.particleCount) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const radius = CONFIG.treeRadius * Math.pow(1 - progress, 0.9) + Math.random();
                treePositions[i*3] = Math.cos(angle) * radius;
                treePositions[i*3+1] = y;
                treePositions[i*3+2] = Math.sin(angle) * radius;

                // Scatter
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = CONFIG.scatterRadius * Math.cbrt(Math.random());
                scatterPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                scatterPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                scatterPositions[i*3+2] = r * Math.cos(phi);

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.0 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uState: { value: 0 },
                    uColor1: { value: new THREE.Color(0xffd700) }, // Gold
                    uColor2: { value: new THREE.Color(0xff4500) }  // Red-Orange
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);
            
            // Top Star
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            worldGroup.add(star);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 15).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const aspectRatio = texture.image.width / texture.image.height;
                        
                        const photoGeo = new THREE.PlaneGeometry(4 * aspectRatio, 4);
                        const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                        
                        // Golden Frame
                        const frameGeo = new THREE.PlaneGeometry(4 * aspectRatio + 0.2, 4.2);
                        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                        const frameMesh = new THREE.Mesh(frameGeo, frameMat);
                        frameMesh.position.z = -0.02;
                        photoMesh.add(frameMesh);

                        // Default Tree Position
                        const angle = Math.random() * Math.PI * 2;
                        const y = (Math.random() - 0.5) * CONFIG.treeHeight * 0.7;
                        const r = CONFIG.treeRadius + 2;
                        photoMesh.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                        photoMesh.lookAt(0, y, 0);
                        
                        photoGroup.add(photoMesh);
                        photoParticles.push({ 
                            mesh: photoMesh, 
                            treePos: photoMesh.position.clone(),
                            treeRot: photoMesh.rotation.clone(),
                            index: photoParticles.length 
                        });
                        
                        if(currentState === 'TREE') toTreeState();
                    });
                };
                reader.readAsDataURL(file);
            });
            showMode("PHOTOS ADDED");
        }

        function switchState(newState) {
            if (currentState === newState) return;
            // Prevent entering Gallery if no photos
            if ((newState === 'CAROUSEL' || newState === 'ZOOM') && photoParticles.length === 0) {
                showMode("ADD PHOTOS FIRST");
                return;
            }

            currentState = newState;
            showMode(currentState);

            if (currentState === 'TREE') toTreeState();
            else if (currentState === 'CAROUSEL') toCarouselState();
            else if (currentState === 'ZOOM') toZoomState();
        }

        function showMode(text) {
            const el = document.getElementById('mode-indicator');
            el.innerText = text;
            el.style.opacity = 1;
            clearTimeout(el.timeout);
            el.timeout = setTimeout(() => el.style.opacity = 0, 2000);
        }

        // --- State Transitions ---

        function toTreeState() {
            // Particles -> Tree Shape
            gsap.to(animState, { value: 0, duration: 2, ease: "power2.inOut", 
                onUpdate: () => { particleSystem.material.uniforms.uState.value = animState.value; }
            });
            // Camera Reset
            gsap.to(camera.position, { duration: 2, x: 0, y: 2, z: 45 });
            gsap.to(camera.rotation, { duration: 2, x: 0, y: 0, z: 0 });
            gsap.to(worldGroup.rotation, { duration: 2, x: 0, z: 0 }); // Allow Y auto-rotate later

            // Photos return to tree
            photoParticles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 2, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, ease: "back.out(1)" });
                gsap.to(p.mesh.rotation, { duration: 2, x: p.treeRot.x, y: p.treeRot.y, z: p.treeRot.z });
                gsap.to(p.mesh.scale, { duration: 1, x: 1, y: 1, z: 1 });
            });
        }

        function toCarouselState() {
            // Particles -> Scatter (Background)
            gsap.to(animState, { value: 1, duration: 2 });
            gsap.to(camera.position, { duration: 2, x: 0, y: 0, z: 40 });
            gsap.to(worldGroup.rotation, { duration: 2, x: 0, y: 0, z: 0 }); // Reset world rotation

            const count = photoParticles.length;
            const angleStep = (Math.PI * 2) / count;

            photoParticles.forEach((p, i) => {
                const angle = i * angleStep;
                const x = Math.cos(angle) * CONFIG.carouselRadius;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                
                // Move to ring
                gsap.to(p.mesh.position, { duration: 2, x: x, y: 0, z: z, ease: "power2.out" });
                // Look at center (plus PI to face outward)
                const targetRot = Math.atan2(x, z) + Math.PI;
                gsap.to(p.mesh.rotation, { duration: 2, x: 0, y: targetRot, z: 0 });
                gsap.to(p.mesh.scale, { duration: 2, x: 1.5, y: 1.5, z: 1.5 });
            });
        }

        function toZoomState() {
            // Find the photo currently closest to the camera (highest Z in world space)
            // Since we rotate the group, we need to calculate effective position
            let bestDist = -Infinity;
            let targetP = null;

            photoParticles.forEach(p => {
                // Approximate world Z (simplified since group rotation handles the spin)
                // We actually just need to find the one facing front based on Carousel logic
                // Or simply: find the one with largest Z after rotation apply
                // Let's rely on calculation:
                const angle = (p.index / photoParticles.length) * Math.PI * 2 + carouselAngleOffset;
                const z = Math.sin(angle) * CONFIG.carouselRadius; // Z is depth here
                if (z > bestDist) {
                    bestDist = z;
                    targetP = p;
                }
            });

            if (!targetP) return;

            // Bring target to front center
            gsap.to(targetP.mesh.position, { duration: 1, x: 0, y: 0, z: 32, ease: "power3.out" }); // Close to camera (45)
            gsap.to(targetP.mesh.rotation, { duration: 1, x: 0, y: 0, z: 0 }); // Face camera
            gsap.to(targetP.mesh.scale, { duration: 1, x: 3, y: 3, z: 3 }); // Big Zoom

            // Push others back slightly
            photoParticles.forEach(p => {
                if (p !== targetP) {
                    gsap.to(p.mesh.scale, { duration: 1, x: 0.5, y: 0.5, z: 0.5 });
                }
            });
        }

        // --- MediaPipe Gestures ---

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.65, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start()
                .then(() => { gsap.to('#loader', { duration: 0.5, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); })
                .catch(err => { console.error(err); document.getElementById('loader').innerText = "CAMERA ERROR"; });
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detectGesture(results.multiHandLandmarks[0]);
            }
        }

        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];

            // 1. Calculate Pinch Distance (Index to Thumb)
            const pinchDist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // 2. Calculate Fist (Fingertips to Wrist)
            let tipsDist = 0;
            [8, 12, 16, 20].forEach(i => {
                tipsDist += Math.sqrt(Math.pow(landmarks[i].x - wrist.x, 2) + Math.pow(landmarks[i].y - wrist.y, 2));
            });
            const isFist = (tipsDist / 4) < 0.18;

            // --- Logic ---

            // Priority 1: Fist -> Reset
            if (isFist) {
                if (currentState !== 'TREE') switchState('TREE');
                return;
            }

            // Priority 2: Pinch (Close) -> Enter Gallery
            if (pinchDist < 0.05) {
                if (currentState !== 'CAROUSEL') switchState('CAROUSEL');
                return;
            }

            // Priority 3: Spread (Index/Thumb Open) -> Zoom
            // Only acts if we are ALREADY in Gallery
            if (currentState === 'CAROUSEL' && pinchDist > 0.20) {
                switchState('ZOOM');
            }
            
            // Note: Removed "Scatter" on open hand to avoid conflict with Zoom.
            // Zoom implies opening hand, so let's keep it specific.
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if (particleSystem) particleSystem.material.uniforms.uTime.value = time;

            if (currentState === 'CAROUSEL') {
                // Auto rotate carousel slowly
                carouselAngleOffset += 0.002;
                
                // Update photo positions based on carousel rotation
                const count = photoParticles.length;
                if (count > 0) {
                    const angleStep = (Math.PI * 2) / count;
                    photoParticles.forEach((p, i) => {
                        const currentAngle = i * angleStep + carouselAngleOffset;
                        p.mesh.position.x = Math.cos(currentAngle) * CONFIG.carouselRadius;
                        p.mesh.position.z = Math.sin(currentAngle) * CONFIG.carouselRadius;
                        // Always face center + PI to face out
                        p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                    });
                }
            } else if (currentState === 'TREE') {
                // Auto rotate tree slowly
                worldGroup.rotation.y += 0.002;
            }
            // In ZOOM mode, we stop rotation to focus on the photo

            composer.render();
        }

        init();
    </script>
</body>
</html>
