<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Starfall Reveal</title>
    <style>
        /* çº¯é»‘èƒŒæ™¯ï¼Œæè‡´å¯¹æ¯”åº¦ */
        body { margin: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box;
            z-index: 20; color: #fff;
            /* ä»…é¡¶éƒ¨å’Œåº•éƒ¨æœ‰è½»å¾®é®ç½©ï¼Œä¸­é—´å®Œå…¨é€šé€ */
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 15%, transparent 85%, rgba(0,0,0,0.6) 100%);
        }
        
        h1 { 
            margin: 10px 0 5px 0; font-weight: 300; text-transform: uppercase; 
            font-size: 24px; color: #fffdd0; letter-spacing: 8px; text-align: center;
            text-shadow: 0 0 30px rgba(255, 253, 208, 0.8); /* å¥¶æ²¹è‰²è¶…å¼ºè¾‰å…‰ */
        }

        #upload-area { pointer-events: auto; text-align: center; }
        #upload-btn {
            background: rgba(255, 253, 208, 0.1);
            border: 1px solid rgba(255, 253, 208, 0.3); 
            color: #fffdd0; padding: 10px 24px; cursor: pointer;
            text-transform: uppercase; font-size: 11px; letter-spacing: 3px;
            transition: all 0.4s; display: inline-block; border-radius: 30px;
            backdrop-filter: blur(5px);
        }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1.5s ease-out;
        }

        #guide {
            text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px; color: rgba(255,255,255,0.4); letter-spacing: 1px; line-height: 2.0;
        }
        .key { color: #fffdd0; font-weight: bold; margin: 0 5px; font-size: 14px; text-shadow: 0 0 10px currentColor;}
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    
    <div id="loader">
        <div style="letter-spacing: 6px; font-size: 16px; color: #fffdd0; text-shadow: 0 0 20px #fffdd0;">IGNITING STARS...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <div id="upload-area">
                <label for="file-input" id="upload-btn">Inject Memories</label>
                <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            </div>
        </div>
        
        <div id="guide">
            <span class="key">ğŸ–</span> å¼ æ‰‹æ§åˆ¶æ˜Ÿè¾° Â· <span class="key">âœŠ</span> æ¡æ‹³å¤ä½<br>
            <span class="key">âœŒï¸</span> å‰ªåˆ€æ‰‹ç¿»ç‰Œå±•ç¤ºç…§ç‰‡
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 5000, // çº¯ç²¹çš„é«˜å¯†åº¦æ˜Ÿè¾°
            treeHeight: 35,
            treeRadius: 12,
            scatterRadius: 65,
            handSensitivity: 1.3
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup;
        let photoParticles = [];
        let currentPhotoIndex = -1; // å½“å‰å±•ç¤ºçš„ç…§ç‰‡ç´¢å¼•
        
        let currentMode = 'ANALOG'; // 'ANALOG' (æ§åˆ¶æ˜Ÿè¾°), 'ZOOM' (å±•ç¤ºç…§ç‰‡)
        let targetExpansion = 0;    
        let currentExpansion = 0;   

        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        worldGroup.add(photoGroup);

        // --- Shader: å›å½’æœ€æ¢¦å¹»çš„æ˜Ÿè¾°æ•ˆæœ ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState;
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            void main() {
                vRandom = aRandom;
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                // å¤æ‚çš„å¸ƒæœ—è¿åŠ¨/å‘¼å¸æ„Ÿ
                float noiseAmp = 0.1 + 0.4 * uState;
                float noise = sin(uTime * 1.2 + aRandom * 15.0) * noiseAmp;
                float noise2 = cos(uTime * 1.5 + aRandom * 12.0) * noiseAmp;
                pos.x += noise; 
                pos.y += noise * 0.5 + uState * 2.0; // æ•£å¼€æ—¶ç¼“æ…¢ä¸Šå‡
                pos.z += noise2;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // æ•£å¼€æ—¶ç²’å­å˜å¤§ï¼Œä¸”å¼ºçƒˆé—ªçƒ
                float sizeState = 1.0 + uState * 1.2; 
                float twinkle = sin(uTime * 3.0 + aRandom * 25.0) * 0.5 + 0.5;
                // è·ç¦»è¡°å‡è®¡ç®—ï¼Œè®©è¿œå¤„çš„æ˜Ÿæ˜Ÿæ›´å°
                gl_PointSize = aSize * sizeState * (280.0 / -mvPosition.z) * (0.2 + 0.8 * twinkle);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform float uOpacity; // æ–°å¢é€æ˜åº¦æ§åˆ¶
            varying float vRandom;
            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;
                // æå…¶æŸ”å’Œçš„å…‰æ™•
                float strength = pow(1.0 - dist * 2.0, 2.5);
                
                // é¦™æ§Ÿé‡‘åˆ°æš–ç™½çš„æ¸å˜
                vec3 color = mix(uColor1, uColor2, vRandom);
                color = mix(color, vec3(1.0, 1.0, 1.0), strength * 0.6); // æ ¸å¿ƒæäº®
                
                gl_FragColor = vec4(color * strength * 2.0, strength * uOpacity);
            }
        `;

        async function init() {
            scene = new THREE.Scene();
            // ææ·±é‚ƒçš„å®‡å®™å°˜åŸƒé›¾æ°”
            scene.fog = new THREE.FogExp2(0x020105, 0.004);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 48);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4; // é«˜æ›å…‰ï¼Œè®©è¾‰å…‰çˆ†å¼€
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            // ç¯å…‰åªç”¨äºç…§äº®ç…§ç‰‡ï¼Œæ˜Ÿè¾°è‡ªå¸¦å‘å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const frontLight = new THREE.DirectionalLight(0xffffff, 2.0);
            frontLight.position.set(0, 0, 10);
            scene.add(frontLight);

            // æè‡´è¾‰å…‰é…ç½®
            const renderScene = new RenderPass(scene, camera);
            // åŠå¾„å¾ˆå¤§ï¼Œå¼ºåº¦å¾ˆé«˜ï¼Œè¥é€ æ¢¦å¹»æ„Ÿ
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.8, 1.0, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupMediaPipe();
            animate();
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const treePositions = new Float32Array(count * 3);
            const scatterPositions = new Float32Array(count * 3);
            const randoms = new Float32Array(count);
            const sizes = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                // Tree: è‡ªç„¶çš„èºæ—‹å †ç§¯
                const angle = i * 0.15 + Math.random() * 0.5;
                const y = (i / count) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const radius = CONFIG.treeRadius * Math.pow(1 - progress, 1.1) + Math.random()*1.0;
                treePositions[i*3] = Math.cos(angle) * radius;
                treePositions[i*3+1] = y;
                treePositions[i*3+2] = Math.sin(angle) * radius;

                // Scatter: å·¨å¤§çš„æ˜Ÿç³»ç›˜
                const sAngle = Math.random() * Math.PI * 2;
                const sRadius = Math.random() * CONFIG.scatterRadius * (0.4 + 0.6*Math.random());
                scatterPositions[i*3] = Math.cos(sAngle) * sRadius;
                scatterPositions[i*3+1] = (Math.random() - 0.5) * 30 * (1-sRadius/CONFIG.scatterRadius); 
                scatterPositions[i*3+2] = Math.sin(sAngle) * sRadius;

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.5 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uState: { value: 0 },
                    uOpacity: { value: 1.0 }, // æ§åˆ¶æ•´ä½“é€æ˜åº¦
                    uColor1: { value: new THREE.Color(0xfffdd0) }, // å¥¶æ²¹ç™½
                    uColor2: { value: new THREE.Color(0xd4af37) }  // é¦™æ§Ÿé‡‘
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // åŠ æ³•æ··åˆï¼Œè¶Šå è¶Šäº®
            });

            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);
            
            // é¡¶éƒ¨ä¼¯åˆ©æ’ä¹‹æ˜Ÿ (è¶…äº®æ ¸å¿ƒ)
            const starGeo = new THREE.SphereGeometry(1.0, 16, 16);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.treeHeight/2 + 2.5, 0);
            star.add(new THREE.PointLight(0xffffff, 4, 80));
            worldGroup.add(star);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            // éšè—åŸæ¥çš„ç…§ç‰‡ï¼Œåªåœ¨éœ€è¦æ—¶æ˜¾ç¤º
            photoGroup.visible = false; 

            Array.from(files).forEach((file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const ar = texture.image.width / texture.image.height;
                        // åˆ›å»ºåŸºæœ¬ç…§ç‰‡å¹³é¢
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(ar, 1), // åŸºç¡€æ¯”ä¾‹ï¼Œåé¢ä¼šç¼©æ”¾
                            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                        );
                        // ç®€å•çš„å‘å…‰è¾¹æ¡†
                        const frame = new THREE.Mesh(
                            new THREE.PlaneGeometry(ar + 0.05, 1.05),
                            new THREE.MeshBasicMaterial({ color: 0xfffdd0 })
                        );
                        frame.position.z = -0.01;
                        mesh.add(frame);
                        
                        // åˆå§‹éšè—åœ¨å±å¹•å¤–
                        mesh.position.set(0, -100, 0);
                        mesh.visible = false;
                        
                        photoGroup.add(mesh);
                        photoParticles.push(mesh);
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        // --- MediaPipe & æç®€äº¤äº’é€»è¾‘ ---

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.65, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start().then(() => { 
                gsap.to('#loader', { duration: 1.5, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); 
            });
        }

        // è¾…åŠ©ï¼šåˆ¤æ–­æ‰‹æŒ‡ä¼¸ç›´
        function isStraight(lm, tipIdx, pipIdx) {
             return Math.hypot(lm[tipIdx].x - lm[0].x, lm[tipIdx].y - lm[0].y) > Math.hypot(lm[pipIdx].x - lm[0].x, lm[pipIdx].y - lm[0].y) * 1.1;
        }

        let gestureCooldown = false; // é˜²æ­¢æ‰‹åŠ¿é‡å¤è§¦å‘

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // 1. å¼ å¼€åº¦ (ç”¨äºçº¿æ€§æ§åˆ¶)
                const handSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                let tipDist = 0;
                [8,12,16,20].forEach(i => tipDist += Math.hypot(lm[i].x - lm[0].x, lm[i].y - lm[0].y));
                let force = ((tipDist/4)/handSize - 0.9); 
                force = Math.max(0, Math.min(1, force * CONFIG.handSensitivity));

                // 2. æ‰‹åŠ¿åˆ¤å®š
                const iS=isStraight(lm,8,6), mS=isStraight(lm,12,10), rS=isStraight(lm,16,14), pS=isStraight(lm,20,18);

                // âœŠ æ¡æ‹³å¤ä½
                if(force < 0.15 && !iS && !mS && !rS && !pS) {
                    if(currentMode !== 'ANALOG') exitToTree();
                    return;
                }

                // âœŒï¸ å‰ªåˆ€æ‰‹ -> ç¿»ç‰Œå±•ç¤ºç…§ç‰‡ (å¸¦å†·å´æ—¶é—´)
                if(iS && mS && !rS && !pS && photoParticles.length > 0 && !gestureCooldown) {
                    if(currentMode === 'ANALOG') {
                        enterFlipReveal();
                        // è®¾ç½®å†·å´ï¼Œé˜²æ­¢è¿ç»­è§¦å‘
                        gestureCooldown = true;
                        setTimeout(() => gestureCooldown = false, 2000); 
                    }
                    return;
                }

                // ğŸ– çº¿æ€§æ§åˆ¶
                if(currentMode === 'ANALOG') {
                    targetExpansion = force;
                }
            } else {
                if(currentMode === 'ANALOG') targetExpansion = 0;
            }
        }

        // --- åŠ¨ç”»çŠ¶æ€ ---

        function exitToTree() {
            currentMode = 'ANALOG';
            targetExpansion = 0;
            // æ˜Ÿè¾°æ¢å¤ä¸é€æ˜
            gsap.to(particleSystem.material.uniforms.uOpacity, {value: 1.0, duration: 1.5});
            // éšè—æ‰€æœ‰ç…§ç‰‡
            photoGroup.visible = false;
            photoParticles.forEach(p => p.visible = false);
        }

        function enterFlipReveal() {
            currentMode = 'ZOOM';
            targetExpansion = 1; // èƒŒæ™¯ä¿æŒæ•£å¼€

            // 1. æ˜Ÿè¾°å˜æš—é€€å
            gsap.to(particleSystem.material.uniforms.uOpacity, {value: 0.3, duration: 1.5});
            
            // 2. å‡†å¤‡ä¸‹ä¸€å¼ ç…§ç‰‡
            currentPhotoIndex = (currentPhotoIndex + 1) % photoParticles.length;
            const photo = photoParticles[currentPhotoIndex];
            
            photoGroup.visible = true;
            photoParticles.forEach(p => p.visible = false); // éšè—å…¶ä»–
            photo.visible = true;

            // 3. è®¾ç½®åˆå§‹çŠ¶æ€ (åœ¨å±å¹•ä¸­å¿ƒï¼ŒèƒŒå¯¹é•œå¤´ï¼Œå¾ˆå°)
            photo.position.set(0, 0, 40); 
            photo.rotation.set(0, Math.PI, 0); // èƒŒé¢
            photo.scale.set(0.1, 0.1, 0.1);

            // 4. ç¿»è½¬åŠ¨ç”» sequence
            const tl = gsap.timeline();
            // é£å‘é•œå¤´å¹¶ç¿»è½¬
            tl.to(photo.position, { z: 38, duration: 1.2, ease: "power3.out" }, 0);
            tl.to(photo.rotation, { y: 0, duration: 1.2, ease: "back.out(1.5)" }, 0); // ç¿»è½¬è¿‡æ¥
            // åŒæ—¶å˜å·¨å¤§
            tl.to(photo.scale, { x: 15, y: 15, z: 15, duration: 1.2, ease: "power3.out" }, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // å¹³æ»‘æ’å€¼æ‰‹åŠ¿æ§åˆ¶
            if(currentMode === 'ANALOG') {
                currentExpansion += (targetExpansion - currentExpansion) * 0.1;
            } else {
                currentExpansion += (1.0 - currentExpansion) * 0.08;
            }

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uState.value = currentExpansion;
            }

            // ç¼“æ…¢è‡ªè½¬
            if(currentMode === 'ANALOG') {
                worldGroup.rotation.y += 0.001 + currentExpansion * 0.002;
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
