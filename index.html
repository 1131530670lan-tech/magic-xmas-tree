<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Xmas Dream</title>
    <style>
        /* èƒŒæ™¯çº¯é»‘ï¼Œæœ€å¤§åŒ–å…‰å½±å¯¹æ¯” */
        body { margin: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box;
            z-index: 10; color: #fff;
        }
        
        /* æ¨¡ä»¿å‚è€ƒå›¾çš„æ ‡é¢˜é£æ ¼ */
        h1 { 
            margin: 0 0 10px 0; font-weight: 400; text-transform: uppercase; 
            font-size: 28px; color: #f0e68c; letter-spacing: 5px; text-align: center;
            text-shadow: 0 0 20px rgba(240, 230, 140, 0.6);
        }
        
        /* æç®€çš„å°æŒ‰é’® */
        .sub-controls { text-align: center; }
        #upload-btn {
            background: transparent;
            border: 1px solid rgba(240, 230, 140, 0.4); color: #f0e68c; 
            padding: 6px 12px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 10px; letter-spacing: 2px;
            transition: all 0.3s; display: inline-block;
        }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1s ease-out;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-family: sans-serif; font-size: 10px; color: rgba(255,255,255,0.5);
            letter-spacing: 1px; text-transform: uppercase;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    <div id="loader">
        <div style="letter-spacing: 3px; font-size: 14px;">IGNITING STARS...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <div class="sub-controls">
                <label for="file-input" id="upload-btn">ADD MEMORIES</label>
                <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            </div>
        </div>
        
        <div id="guide">
            Press âœŠ to gather Â· ğŸ– to scatter Â· ğŸ‘Œ for gallery
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 4000, // ç²’å­æ•°é‡å¤§å¹…å¢åŠ 
            treeHeight: 35,
            treeRadius: 12,
            scatterRadius: 50,
            carouselRadius: 20
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup;
        let photoParticles = [];
        let currentState = 'TREE'; 
        let targetRotationY = 0;
        let carouselRotation = 0;
        // ç”¨äº GSAP åŠ¨ç”»çš„ä¸­é—´å˜é‡
        const animState = { transition: 0 }; 
        
        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        worldGroup.add(photoGroup);

        let touchStartX = 0; let isTouching = false;

        // --- GLSL Shaders ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState; // 0=Tree, 1=Scattered
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                vRandom = aRandom;
                // åœ¨æ ‘å½¢æ€å’Œæ•£å¼€å½¢æ€ä¹‹é—´æ’å€¼
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                vPos = pos;

                // æ·»åŠ åŸºäºæ—¶é—´çš„å™ªç‚¹è¿åŠ¨ï¼Œè®©ç²’å­â€œå‘¼å¸â€
                float noise = sin(uTime * 2.0 + aRandom * 10.0) * 0.2;
                pos.x += noise * uState; // æ•£å¼€æ—¶åŠ¨å¾—æ›´å‰å®³
                pos.y += noise * 0.5;
                pos.z += cos(uTime * 2.0 + aRandom * 10.0) * 0.2 * uState;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // é—ªçƒæ•ˆæœ
                float twinkle = sin(uTime * 3.0 + aRandom * 20.0) * 0.5 + 0.5;
                // å¤§å°éšè·ç¦»è¡°å‡ï¼Œå¹¶å—é—ªçƒå½±å“
                gl_PointSize = aSize * (200.0 / -mvPosition.z) * (0.3 + 0.7 * twinkle);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                // åˆ›å»ºæŸ”å’Œçš„åœ†å½¢è¾‰å…‰ç²’å­
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;

                // æ ¸å¿ƒéå¸¸äº®ï¼Œè¾¹ç¼˜å¿«é€Ÿè¡°å‡
                float strength = pow(1.0 - dist * 2.0, 2.0);
                
                // é¢œè‰²åœ¨é‡‘è‰²å’Œæš–æ©™è‰²ä¹‹é—´éšæœºæ··åˆ
                vec3 color = mix(uColor1, uColor2, vRandom);
                
                // æ ¹æ®é«˜åº¦å¢åŠ ä¸€ç‚¹è‰²å½©å˜åŒ–ï¼Œåº•éƒ¨åçº¢ï¼Œé¡¶éƒ¨åç™½
                color += vec3(0.1, 0.05, 0.0) * (vPos.y / 20.0);

                gl_FragColor = vec4(color * strength * 1.5, strength);
            }
        `;


        async function init() {
            scene = new THREE.Scene();
            // ææ·¡çš„é‡‘è‰²é›¾æ°”ï¼Œå¢åŠ ç©ºæ°”æ„Ÿ
            scene.fog = new THREE.FogExp2(0x1a1205, 0.008);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 45);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            setupLighting();
            setupPostProcessing();
            createParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupTouchEvents();
            setupMediaPipe();
            animate();
        }

        function setupLighting() {
            // å¼ºçƒˆçš„ä¸­å¿ƒæš–å…‰ï¼Œç…§äº®ç…§ç‰‡
            const mainLight = new THREE.PointLight(0xffd700, 5, 100);
            mainLight.position.set(0, 10, 0);
            worldGroup.add(mainLight);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            // æè‡´è¾‰å…‰å‚æ•°ï¼šå¼ºåº¦æé«˜ï¼ŒåŠå¾„å¤§
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 3.0, 1.0, 0.9);
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function setupTouchEvents() {
            document.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; isTouching = true; }, {passive: false});
            document.addEventListener('touchmove', (e) => {
                if (!isTouching) return;
                const diffX = e.touches[0].clientX - touchStartX;
                if (currentState === 'CAROUSEL') carouselRotation += diffX * 0.008;
                else if (currentState === 'SCATTERED') worldGroup.rotation.y += diffX * 0.005;
                touchStartX = e.touches[0].clientX;
                if(e.cancelable) e.preventDefault(); 
            }, {passive: false});
            document.addEventListener('touchend', () => { isTouching = false; });
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const treePositions = new Float32Array(CONFIG.particleCount * 3);
            const scatterPositions = new Float32Array(CONFIG.particleCount * 3);
            const randoms = new Float32Array(CONFIG.particleCount);
            const sizes = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // æ ‘å½¢ä½ç½® (èºæ—‹åœ†é”¥)
                const angle = i * 0.1 + Math.random() * 0.5; // å¢åŠ éšæœºæ€§è®©åˆ†å¸ƒæ›´è‡ªç„¶
                const y = (i / CONFIG.particleCount) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const radius = CONFIG.treeRadius * Math.pow(1 - progress, 0.9) + Math.random(); // å¢åŠ ä¸€ç‚¹éšæœºåŠå¾„æŠ–åŠ¨
                treePositions[i*3] = Math.cos(angle) * radius;
                treePositions[i*3+1] = y;
                treePositions[i*3+2] = Math.sin(angle) * radius;

                // æ•£å¼€ä½ç½® (éšæœºçƒä½“)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = CONFIG.scatterRadius * Math.cbrt(Math.random());
                scatterPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                scatterPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta) * 1.5; // Yè½´æ‹‰ä¼¸
                scatterPositions[i*3+2] = r * Math.cos(phi);

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.0 + 1.0; // åŸºç¡€å¤§å°å·®å¼‚
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3)); // åˆå§‹ä½ç½®
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uState: { value: 0 }, // 0=Tree, 1=Scattered
                    uColor1: { value: new THREE.Color(0xffd700) }, // é‡‘è‰²
                    uColor2: { value: new THREE.Color(0xff8c00) }  // æš–æ©™è‰²
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false, // å…³é”®ï¼šå…³é—­æ·±åº¦å†™å…¥ï¼Œå®ç°ç²’å­å åŠ 
                blending: THREE.AdditiveBlending // å…³é”®ï¼šåŠ æ³•æ··åˆï¼Œè¶Šå åŠ è¶Šäº®
            });

            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);

            // é¡¶éƒ¨è¶…äº®æ˜Ÿå…‰
            const starGeo = new THREE.SphereGeometry(1.5, 16, 16);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            // ç»™æ˜Ÿæ˜ŸåŠ ä¸€ä¸ªå·¨å¤§çš„ç‚¹å…‰æº
            const starLight = new THREE.PointLight(0xffffff, 10, 50);
            starMesh.add(starLight);
            worldGroup.add(starMesh);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 12).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const aspectRatio = texture.image.width / texture.image.height;
                        
                        // ç…§ç‰‡æœ¬ä½“
                        const photoGeo = new THREE.PlaneGeometry(3 * aspectRatio, 3);
                        const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                        
                        // å‘å…‰è¾¹æ¡†
                        const frameGeo = new THREE.PlaneGeometry(3 * aspectRatio + 0.1, 3.1);
                        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                        const frameMesh = new THREE.Mesh(frameGeo, frameMat);
                        frameMesh.position.z = -0.01;
                        photoMesh.add(frameMesh);

                        // åˆå§‹ä½ç½®
                        const angle = (index / files.length) * Math.PI * 2;
                        const radius = CONFIG.treeRadius + 2;
                        const y = (Math.random() - 0.5) * CONFIG.treeHeight * 0.6;
                        photoMesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                        photoMesh.lookAt(0, y, 0);
                        
                        photoGroup.add(photoMesh);
                        photoParticles.push({ mesh: photoMesh, treePos: photoMesh.position.clone(), carouselAngle: 0 });

                        if(currentState === 'TREE') toTreeState();
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function switchState(newState) {
            if (currentState === newState) return;
            if (newState === 'CAROUSEL' && photoParticles.length === 0) return;
            currentState = newState;

            if (currentState === 'TREE') toTreeState();
            else if (currentState === 'SCATTERED') toScatteredState();
            else if (currentState === 'CAROUSEL') toCarouselState();
        }

        function toTreeState() {
            // Shader åŠ¨ç”»ï¼šè¿‡æ¸¡åˆ°çŠ¶æ€ 0
            gsap.to(animState, { value: 0, duration: 2.5, ease: "power2.inOut", 
                onUpdate: () => { particleSystem.material.uniforms.uState.value = animState.value; }
            });
            gsap.to(camera.position, { duration: 2, x: 0, y: 2, z: 45, ease: "power2.inOut" });
            gsap.to(worldGroup.rotation, { duration: 2, x: 0, z: 0 });
            
            photoParticles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 2, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, ease: "power2.inOut" });
                gsap.to(p.mesh.rotation, { duration: 2, x: 0, y: Math.atan2(p.treePos.x, p.treePos.z), z: 0 });
                gsap.to(p.mesh.scale, { duration: 1.5, x: 1, y: 1, z: 1 });
            });
        }

        function toScatteredState() {
            // Shader åŠ¨ç”»ï¼šè¿‡æ¸¡åˆ°çŠ¶æ€ 1
            gsap.to(animState, { value: 1, duration: 3, ease: "power3.out", 
                onUpdate: () => { particleSystem.material.uniforms.uState.value = animState.value; }
            });
            gsap.to(camera.position, { duration: 3, z: 60, ease: "power2.out" });
            
            photoParticles.forEach(p => {
                // ç…§ç‰‡ä¹Ÿæ•£å¼€åˆ°è¿œå¤„
                gsap.to(p.mesh.position, { 
                    duration: 3, 
                    x: p.treePos.x * 3 + (Math.random()-0.5)*20, 
                    y: p.treePos.y * 3 + (Math.random()-0.5)*20, 
                    z: p.treePos.z * 3 + (Math.random()-0.5)*20, 
                    ease: "power3.out" 
                });
                gsap.to(p.mesh.rotation, { duration: 3, x: Math.random()*3, y: Math.random()*3, z: Math.random()*3 });
            });
        }
        
        function toCarouselState() {
            // ç²’å­ä¿æŒæ•£å¼€çŠ¶æ€
            gsap.to(animState, { value: 1, duration: 2 });
            
            const count = photoParticles.length;
            photoParticles.forEach((p, index) => {
                const angle = (index / count) * Math.PI * 2;
                p.carouselAngle = angle;
                const x = Math.cos(angle) * CONFIG.carouselRadius;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                
                gsap.to(p.mesh.position, { duration: 2, x: x, y: 0, z: z, ease: "power2.out" });
                gsap.to(p.mesh.rotation, { duration: 2, x: 0, y: Math.atan2(x, z) + Math.PI, z: 0 });
                gsap.to(p.mesh.scale, { duration: 2, x: 1.5, y: 1.5, z: 1.5 });
            });
            
            carouselRotation = 0;
            gsap.to(camera.position, { duration: 2, x: 0, y: 0, z: 35 });
            gsap.to(worldGroup.rotation, { duration: 2, x: 0, y: 0, z: 0 });
        }

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user' // è¿›ä¸€æ­¥é™ä½åˆ†è¾¨ç‡æå‡æ€§èƒ½
            });
            cameraUtils.start()
                .then(() => { gsap.to('#loader', { duration: 1, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); })
                .catch(err => { console.error(err); document.getElementById('loader').innerHTML = "<div style='color:#d4af37; text-align:center'>Camera access needed<br>for gestures.</div>"; gsap.to('#loader', { delay: 3, duration: 1, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); });
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGesture(landmarks);
            }
        }

        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            let avgDist = 0;
            [8, 12, 16, 20].forEach(idx => { avgDist += Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2)); });
            avgDist /= 4;
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            const handX = 1.0 - landmarks[9].x; 

            if (avgDist < 0.18) { if(currentState !== 'TREE') switchState('TREE'); } 
            else if (pinchDist < 0.05 && photoParticles.length > 0) { if (currentState !== 'CAROUSEL') switchState('CAROUSEL'); }
            else if (avgDist > 0.38) { if(currentState === 'TREE') switchState('SCATTERED'); }

            if (currentState === 'CAROUSEL') { targetRotationY = (Math.max(0.2, Math.min(0.8, handX)) - 0.5) * Math.PI * 5; } 
            else if (currentState === 'SCATTERED') { targetRotationY = (handX - 0.5) * 5; }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // æ›´æ–° Shader æ—¶é—´ uniform
            if (particleSystem) particleSystem.material.uniforms.uTime.value = time;

            if (currentState === 'CAROUSEL') {
                carouselRotation += (targetRotationY - carouselRotation) * 0.05;
                photoParticles.forEach(p => {
                    const currentAngle = p.carouselAngle + carouselRotation;
                    p.mesh.position.x = Math.cos(currentAngle) * CONFIG.carouselRadius;
                    p.mesh.position.z = Math.sin(currentAngle) * CONFIG.carouselRadius;
                    p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                });
                worldGroup.rotation.y += 0.0005;
            } else if (currentState === 'SCATTERED') {
                worldGroup.rotation.y += (targetRotationY - worldGroup.rotation.y) * 0.05;
            } else if (currentState === 'TREE') {
                worldGroup.rotation.y += 0.001; // éå¸¸ç¼“æ…¢çš„è‡ªè½¬
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
