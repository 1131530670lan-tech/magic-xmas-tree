<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas Magic: Force Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box;
            z-index: 10; color: #fff;
        }
        
        h1 { 
            margin: 0 0 5px 0; font-weight: 400; text-transform: uppercase; 
            font-size: 24px; color: #f0e68c; letter-spacing: 4px; text-align: center;
            text-shadow: 0 0 20px rgba(240, 230, 140, 0.6);
        }

        #upload-btn {
            background: rgba(0,0,0,0.5); border: 1px solid rgba(240, 230, 140, 0.4); 
            color: #f0e68c; padding: 8px 15px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 10px; letter-spacing: 2px;
            transition: all 0.3s; display: inline-block; border-radius: 20px;
            margin: 0 auto; display: block; width: fit-content;
        }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1s ease-out;
        }

        /* çµæ•åº¦è°ƒè¯•æ¡ */
        #force-bar-container {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px;
            overflow: hidden;
        }
        #force-bar {
            width: 0%; height: 100%; background: #f0e68c; transition: width 0.1s linear;
        }
        #status-text {
            text-align: center; font-size: 10px; color: rgba(240, 230, 140, 0.8); margin-top: 5px; letter-spacing: 1px;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-family: sans-serif; font-size: 10px; color: rgba(255,255,255,0.4);
            letter-spacing: 1px; text-transform: uppercase; line-height: 1.5;
        }
        .key { color: #f0e68c; font-weight: bold; margin: 0 2px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    
    <div id="loader">
        <div style="letter-spacing: 3px; font-size: 14px;">SYNCING FORCE...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <label for="file-input" id="upload-btn">Add Memories</label>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </div>
        
        <div>
            <div id="status-text">WAITING FOR HAND...</div>
            <div id="force-bar-container"><div id="force-bar"></div></div>
        </div>

        <div id="guide">
            <span class="key">ğŸ–</span> Open Hand: Control Explosion<br>
            <span class="key">ğŸ‘Œ</span> Pinch: Gallery Â· <span class="key">ğŸ‘</span> Pinch Open: Zoom
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 5000,
            treeHeight: 35,
            treeRadius: 12,
            scatterRadius: 60,
            carouselRadius: 18,
            handSensitivity: 1.2 // çµæ•åº¦å€ç‡ï¼Œè¶Šå¤§è¶Šå®¹æ˜“ç‚¸å¼€
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup;
        let photoParticles = [];
        
        // æ ¸å¿ƒçŠ¶æ€å˜é‡
        let currentMode = 'ANALOG'; // 'ANALOG' (çº¿æ€§æ§åˆ¶), 'CAROUSEL', 'ZOOM'
        let targetExpansion = 0;    // ç›®æ ‡å±•å¼€åº¦ (0=æ ‘, 1=ç‚¸å¼€)
        let currentExpansion = 0;   // å½“å‰å¹³æ»‘åçš„å±•å¼€åº¦
        
        let activePhotoIndex = 0;
        let carouselAngleOffset = 0;

        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        worldGroup.add(photoGroup);

        // --- Shader (æ”¯æŒçº¿æ€§æ’å€¼) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState; // 0.0 ~ 1.0 çº¿æ€§å˜åŒ–
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                vRandom = aRandom;
                // æ ¸å¿ƒï¼šçº¿æ€§æ’å€¼ä½ç½®
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                vPos = pos;
                
                // åŠ¨æ€å™ªéŸ³ (çˆ†ç‚¸æ—¶æ‰°åŠ¨æ›´å¤§)
                float noiseAmp = 0.1 + 0.2 * uState;
                float noise = sin(uTime * 1.5 + aRandom * 15.0) * noiseAmp;
                pos.x += noise; 
                pos.y += noise * 0.5;
                pos.z += cos(uTime * 1.5 + aRandom * 15.0) * noiseAmp;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // çˆ†ç‚¸æ—¶ç²’å­ç¨å¾®å˜å¤§ä¸€ç‚¹
                float sizeState = 1.0 + uState * 0.5;
                float twinkle = sin(uTime * 3.0 + aRandom * 25.0) * 0.5 + 0.5;
                gl_PointSize = aSize * sizeState * (220.0 / -mvPosition.z) * (0.4 + 0.6 * twinkle);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;
                float strength = pow(1.0 - dist * 2.0, 2.5);
                vec3 color = mix(uColor1, uColor2, vRandom);
                // é¢œè‰²å¢å¼º
                color += vec3(0.2, 0.1, 0.0) * (vPos.y / 30.0);
                gl_FragColor = vec4(color * strength * 2.0, strength);
            }
        `;

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.005);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 45);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            const mainLight = new THREE.PointLight(0xffd700, 5, 100);
            mainLight.position.set(0, 15, 0);
            worldGroup.add(mainLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.8, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupMediaPipe();
            animate();
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const treePositions = new Float32Array(count * 3);
            const scatterPositions = new Float32Array(count * 3);
            const randoms = new Float32Array(count);
            const sizes = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                // Tree
                const angle = i * 0.1 + Math.random() * 0.5;
                const y = (i / count) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const radius = CONFIG.treeRadius * Math.pow(1 - progress, 0.9) + Math.random();
                treePositions[i*3] = Math.cos(angle) * radius;
                treePositions[i*3+1] = y;
                treePositions[i*3+2] = Math.sin(angle) * radius;

                // Scatter (Spiral Galaxy Shape)
                const sAngle = Math.random() * Math.PI * 2;
                const sRadius = Math.random() * CONFIG.scatterRadius;
                scatterPositions[i*3] = Math.cos(sAngle) * sRadius;
                scatterPositions[i*3+1] = (Math.random() - 0.5) * 20;
                scatterPositions[i*3+2] = Math.sin(sAngle) * sRadius;

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.0 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uState: { value: 0 },
                    uColor1: { value: new THREE.Color(0xffd700) },
                    uColor2: { value: new THREE.Color(0xff4500) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);
            
            // Star
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            star.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            worldGroup.add(star);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 15).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const ar = texture.image.width / texture.image.height;
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(4 * ar, 4),
                            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                        );
                        // Gold Frame
                        const frame = new THREE.Mesh(
                            new THREE.PlaneGeometry(4 * ar + 0.2, 4.2),
                            new THREE.MeshBasicMaterial({ color: 0xffd700 })
                        );
                        frame.position.z = -0.02;
                        mesh.add(frame);

                        const angle = Math.random() * Math.PI * 2;
                        const y = (Math.random() - 0.5) * CONFIG.treeHeight * 0.7;
                        const r = CONFIG.treeRadius + 2;
                        mesh.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                        mesh.lookAt(0, y, 0);
                        
                        photoGroup.add(mesh);
                        photoParticles.push({ mesh: mesh, treePos: mesh.position.clone(), treeRot: mesh.rotation.clone(), index: photoParticles.length });
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        // --- MediaPipe & Logic ---

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            // é™ä½è¿½è¸ªç½®ä¿¡åº¦ä»¥æé«˜çµæ•åº¦
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start().then(() => { 
                gsap.to('#loader', { duration: 0.5, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); 
            });
        }

        let lastHandDetectedTime = 0;

        function onResults(results) {
            const now = performance.now();
            const bar = document.getElementById('force-bar');
            const status = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                lastHandDetectedTime = now;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. è®¡ç®—æ‰‹æŒå¼ å¼€å¹…åº¦ (Openness)
                // é€»è¾‘ï¼šè®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»ï¼Œå¹¶å½’ä¸€åŒ–
                const wrist = landmarks[0];
                let totalDist = 0;
                const tips = [8, 12, 16, 20]; // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡
                tips.forEach(i => {
                    const d = Math.sqrt(Math.pow(landmarks[i].x - wrist.x, 2) + Math.pow(landmarks[i].y - wrist.y, 2));
                    totalDist += d;
                });
                const avgDist = totalDist / 4;
                
                // å½’ä¸€åŒ–ï¼šé€šå¸¸æ¡æ‹³æ˜¯ 0.15 å·¦å³ï¼Œå…¨å¼€æ˜¯ 0.35 å·¦å³ (MediaPipe åæ ‡ç³»)
                // æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªèŒƒå›´ [0.15, 0.40] å¹¶æ˜ å°„åˆ° [0, 1]
                let openness = (avgDist - 0.15) / (0.25); 
                openness = Math.max(0, Math.min(1, openness)); // Clamp
                
                // çµæ•åº¦å€ç‡å¢å¼º
                openness = Math.min(1, openness * CONFIG.handSensitivity);

                // æ›´æ–°UIæ¡
                bar.style.width = (openness * 100) + '%';

                // 2. æåˆæ£€æµ‹
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                // --- çŠ¶æ€é€»è¾‘ ---

                // ä¼˜å…ˆçº§ 1: æåˆè¿›å…¥è‰ºå»Š
                if (pinchDist < 0.05) {
                    if (currentMode !== 'CAROUSEL') {
                        enterCarousel();
                        status.innerText = "MODE: GALLERY";
                    }
                    return;
                }

                // ä¼˜å…ˆçº§ 2: åœ¨è‰ºå»Šæ¨¡å¼ä¸‹å¼ æ‰‹ (Zoom)
                if (currentMode === 'CAROUSEL' && pinchDist > 0.25) {
                    if (photoParticles.length > 0) {
                        enterZoom();
                        status.innerText = "MODE: ZOOM";
                    }
                    return;
                }

                // ä¼˜å…ˆçº§ 3: é»˜è®¤æ¨¡å¼ (æ¨¡æ‹Ÿæ§åˆ¶)
                if (currentMode === 'ANALOG') {
                    targetExpansion = openness; // ç›´æ¥æ˜ å°„ï¼
                    // åŠ¨æ€æ›´æ–°æ–‡å­—
                    if (openness < 0.1) status.innerText = "TREE STABLE";
                    else if (openness > 0.9) status.innerText = "FULL POWER";
                    else status.innerText = "EXPANDING...";
                } else if (openness < 0.1) {
                    // åœ¨å…¶ä»–æ¨¡å¼ä¸‹æ¡æ‹³ï¼Œè¿”å›æ ‘æ¨¡å¼
                    exitToTree();
                    status.innerText = "MODE: TREE";
                }

            } else {
                // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹
                if (now - lastHandDetectedTime > 1000) {
                    // å¦‚æœæ‰‹æ¶ˆå¤±è¶…è¿‡1ç§’ï¼Œè‡ªåŠ¨æ…¢æ…¢åˆæ‹¢
                    if (currentMode === 'ANALOG') targetExpansion = 0;
                    status.innerText = "WAITING FOR HAND...";
                    bar.style.width = '0%';
                }
            }
        }

        // --- çŠ¶æ€è½¬æ¢å‡½æ•° ---

        function exitToTree() {
            currentMode = 'ANALOG';
            targetExpansion = 0;
            
            // ç›¸æœºå¤ä½
            gsap.to(camera.position, { duration: 1.5, x: 0, y: 2, z: 45 });
            // ç…§ç‰‡å¤ä½
            photoParticles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 1.5, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z });
                gsap.to(p.mesh.rotation, { duration: 1.5, x: p.treeRot.x, y: p.treeRot.y, z: p.treeRot.z });
                gsap.to(p.mesh.scale, { duration: 1, x: 1, y: 1, z: 1 });
            });
        }

        function enterCarousel() {
            currentMode = 'CAROUSEL';
            // æ­¤æ—¶ expansion ä¿æŒåœ¨æ•£å¼€çŠ¶æ€
            gsap.to(camera.position, { duration: 1.5, x: 0, y: 0, z: 40 });
            
            // ç²’å­å…¨æ•£å¼€ä½œä¸ºèƒŒæ™¯
            targetExpansion = 1; 

            // ç…§ç‰‡æ’æˆåœˆ
            const count = photoParticles.length;
            photoParticles.forEach((p, i) => {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * CONFIG.carouselRadius;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                gsap.to(p.mesh.position, { duration: 1.5, x: x, y: 0, z: z });
                gsap.to(p.mesh.rotation, { duration: 1.5, x: 0, y: Math.atan2(x, z) + Math.PI, z: 0 });
                gsap.to(p.mesh.scale, { duration: 1.5, x: 1.5, y: 1.5, z: 1.5 });
            });
        }

        function enterZoom() {
            currentMode = 'ZOOM';
            // æ‰¾åˆ°æ­£å¯¹å±å¹•çš„ç…§ç‰‡
            // ç®€å•é€»è¾‘ï¼šæ‰¾å½“å‰æ—‹è½¬è§’åº¦ä¸‹ z æœ€å¤§çš„
            let bestP = photoParticles[0];
            let maxZ = -Infinity;
            photoParticles.forEach(p => {
                // ä¼°ç®—æ—‹è½¬åçš„ä½ç½®
                const angle = (p.index / photoParticles.length) * Math.PI * 2 + carouselAngleOffset;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                if(z > maxZ) { maxZ = z; bestP = p; }
            });

            if (bestP) {
                gsap.to(bestP.mesh.position, { duration: 0.8, x: 0, y: 0, z: 35 });
                gsap.to(bestP.mesh.rotation, { duration: 0.8, x: 0, y: 0, z: 0 });
                gsap.to(bestP.mesh.scale, { duration: 0.8, x: 4, y: 4, z: 4 });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // --- æ ¸å¿ƒé€»è¾‘ï¼šå¹³æ»‘æ’å€¼ (Lerp) ---
            // è¿™è®©æ ‘çš„åŠ¨ä½œè·Ÿéšæ‰‹åŠ¿ï¼Œå¸¦æœ‰ç‰©ç†æƒ¯æ€§ï¼Œè€Œä¸æ˜¯ç”Ÿç¡¬çš„è·³å˜
            if (currentMode === 'ANALOG') {
                // 0.1 çš„ç³»æ•°å†³å®šäº†è·Ÿæ‰‹çš„é€Ÿåº¦ã€‚è¶Šå¤§è¶Šå¿«ï¼Œè¶Šå°è¶Šå¹³æ»‘
                currentExpansion += (targetExpansion - currentExpansion) * 0.1;
            } else {
                // åœ¨å…¶ä»–æ¨¡å¼ä¸‹ï¼ŒèƒŒæ™¯ä¿æŒæ•£å¼€
                currentExpansion += (1.0 - currentExpansion) * 0.05;
            }

            // æ›´æ–° Shader çŠ¶æ€
            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uState.value = currentExpansion;
            }

            // æ¨¡å¼ç‰¹å®šçš„åŠ¨ç”»
            if (currentMode === 'ANALOG') {
                worldGroup.rotation.y += 0.001 + (currentExpansion * 0.005); // ç‚¸å¼€æ—¶è½¬å¾—å¿«ä¸€ç‚¹ç‚¹
                
                // ç…§ç‰‡è·Ÿéšæ ‘æˆ–æ•£å¼€
                // ç®€å•çš„æ’å€¼é€»è¾‘è®©ç…§ç‰‡ä¹Ÿè·Ÿéšæ‰‹åŠ¿è¿åŠ¨
                const exp = currentExpansion;
                photoParticles.forEach(p => {
                    // æ ‘ä½ç½®
                    const tx = p.treePos.x; const ty = p.treePos.y; const tz = p.treePos.z;
                    // æ•£å¼€ä½ç½® (ç®€å•æ¨¡æ‹Ÿ)
                    const sx = tx * 3.0; const sy = ty * 3.0; const sz = tz * 3.0;
                    
                    p.mesh.position.x = tx + (sx - tx) * exp;
                    p.mesh.position.y = ty + (sy - ty) * exp;
                    p.mesh.position.z = tz + (sz - tz) * exp;
                    
                    // æ—‹è½¬ä¹Ÿæ’å€¼
                    p.mesh.rotation.x = p.treeRot.x * (1-exp) + (time + p.index)*exp;
                    p.mesh.rotation.y = p.treeRot.y * (1-exp) + (time + p.index)*exp;
                });

            } else if (currentMode === 'CAROUSEL') {
                carouselAngleOffset += 0.002;
                const count = photoParticles.length;
                photoParticles.forEach((p, i) => {
                    const angle = (i / count) * Math.PI * 2 + carouselAngleOffset;
                    p.mesh.position.x = Math.cos(angle) * CONFIG.carouselRadius;
                    p.mesh.position.z = Math.sin(angle) * CONFIG.carouselRadius;
                    p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                });
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
