<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas Supreme: Ornament Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        /* ç•Œé¢å¸ƒå±€ä¼˜åŒ– */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 25px; box-sizing: border-box;
            z-index: 10; color: #fff;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.8) 100%);
        }
        
        h1 { 
            margin: 10px 0; font-weight: 400; text-transform: uppercase; 
            font-size: 24px; color: #f8e8c0; letter-spacing: 5px; text-align: center;
            text-shadow: 0 0 25px rgba(248, 232, 192, 0.6);
        }

        #upload-btn {
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid rgba(248, 232, 192, 0.4); 
            color: #f8e8c0; padding: 10px 24px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 11px; letter-spacing: 2px;
            transition: all 0.3s; display: inline-block; border-radius: 30px;
            margin: 0 auto; display: block; width: fit-content;
            backdrop-filter: blur(5px);
        }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1.2s ease-out;
        }

        /* çµæ•åº¦æ¡ */
        #force-bar-container {
            position: absolute; bottom: 110px; left: 50%; transform: translateX(-50%);
            width: 140px; height: 3px; background: rgba(255,255,255,0.15); border-radius: 2px;
            overflow: hidden;
        }
        #force-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #f8e8c0, #ff6f00); 
            transition: width 0.1s linear; box-shadow: 0 0 10px rgba(255, 111, 0, 0.5);
        }
        #status-text {
            text-align: center; font-size: 10px; color: rgba(248, 232, 192, 0.8); margin-top: 8px; letter-spacing: 2px;
            text-transform: uppercase; text-shadow: 0 0 8px rgba(248, 232, 192, 0.3);
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-family: -apple-system, sans-serif; font-size: 11px; color: rgba(255,255,255,0.5);
            letter-spacing: 0.5px; line-height: 1.8;
        }
        .key { color: #fff; font-weight: bold; margin: 0 3px; font-size: 14px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    
    <div id="loader">
        <div style="letter-spacing: 4px; font-size: 14px; color: #f8e8c0;">DECORATING TREE...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <label for="file-input" id="upload-btn">Add Memories</label>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </div>
        
        <div>
            <div id="status-text">WAITING FOR HAND</div>
            <div id="force-bar-container"><div id="force-bar"></div></div>
        </div>

        <div id="guide">
            <span class="key">ğŸ–</span> å¼ æ‰‹æ§åˆ¶ç‚¸è£‚ Â· <span class="key">âœŠ</span> æ¡æ‹³å¤ä½<br>
            <span class="key">âœŒï¸</span> å‰ªåˆ€æ‰‹è¿›è‰ºå»Š Â· <span class="key">ğŸ‘</span> ç«–å¤§æ‹‡æŒ‡æ”¾å¤§
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 4500, // é‡‘è‰²ç²‰å°˜
            ornamentCount: 450,  // æ–°å¢ï¼šå®ä½“è£…é¥°çƒæ•°é‡
            treeHeight: 35,
            treeRadius: 12,
            scatterRadius: 60,
            carouselRadius: 20,
            handSensitivity: 1.1
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup, ornamentGroup;
        let redInstancedMesh, goldInstancedMesh;
        let photoParticles = [];
        let ornamentData = []; // å­˜å‚¨è£…é¥°çƒçš„ä½ç½®æ•°æ®ç”¨äºåŠ¨ç”»
        
        let currentMode = 'ANALOG'; 
        let targetExpansion = 0;    
        let currentExpansion = 0;   
        let carouselAngleOffset = 0;

        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        ornamentGroup = new THREE.Group();
        
        worldGroup.add(ornamentGroup); // å®ä½“çƒ
        worldGroup.add(photoGroup);    // ç…§ç‰‡

        // --- Shader (ç²’å­) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState;
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            varying vec3 vPos;
            void main() {
                vRandom = aRandom;
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                vPos = pos;
                float noise = sin(uTime * 1.5 + aRandom * 10.0) * (0.1 + 0.3 * uState);
                pos.x += noise; pos.y += noise * 0.5 + uState; pos.z += cos(uTime + aRandom)*noise;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                float sizeState = 1.0 + uState * 0.5;
                float twinkle = sin(uTime * 3.0 + aRandom * 20.0) * 0.5 + 0.5;
                gl_PointSize = aSize * sizeState * (250.0 / -mvPosition.z) * (0.4 + 0.6 * twinkle);
            }
        `;
        const fragmentShader = `
            uniform vec3 uColor1; uniform vec3 uColor2;
            varying float vRandom; varying vec3 vPos;
            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;
                float strength = pow(1.0 - dist * 2.0, 3.0);
                vec3 color = mix(uColor1, uColor2, vRandom);
                color += vec3(0.2, 0.1, 0.0) * (vPos.y / 30.0);
                gl_FragColor = vec4(color * strength * 2.2, strength);
            }
        `;

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020100, 0.005);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 2, 48);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            // ç¯å…‰å¢å¼ºï¼Œä¸ºäº†ç…§äº®å®ä½“çƒ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const mainLight = new THREE.PointLight(0xffd700, 5, 100);
            mainLight.position.set(10, 20, 20);
            worldGroup.add(mainLight);
            const fillLight = new THREE.DirectionalLight(0xff6f00, 2); // æš–å…‰è¡¥å…‰
            fillLight.position.set(-20, 10, 10);
            worldGroup.add(fillLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.8, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();
            createOrnaments(); // æ–°å¢ï¼šåˆ›å»ºå®ä½“çƒ
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupMediaPipe();
            animate();
        }

        function createParticleSystem() {
            // (ä¿æŒåŸæœ‰çš„ç²’å­é€»è¾‘ï¼Œä½†æ•°é‡å¯ä»¥ç¨å¾®å‡å°‘è®©ä½ç»™å®ä½“çƒï¼Œè¿™é‡Œä¿æŒ4500)
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const treePositions = new Float32Array(count * 3);
            const scatterPositions = new Float32Array(count * 3);
            const randoms = new Float32Array(count);
            const sizes = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                const angle = i * 0.15 + Math.random() * 0.5;
                const y = (i / count) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const r = CONFIG.treeRadius * Math.pow(1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight, 0.9) + Math.random();
                treePositions[i*3] = Math.cos(angle)*r; treePositions[i*3+1] = y; treePositions[i*3+2] = Math.sin(angle)*r;

                const sAngle = Math.random() * Math.PI * 2;
                const sRadius = Math.random() * CONFIG.scatterRadius;
                scatterPositions[i*3] = Math.cos(sAngle)*sRadius; 
                scatterPositions[i*3+1] = (Math.random()-0.5)*30; 
                scatterPositions[i*3+2] = Math.sin(sAngle)*sRadius;

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.0 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 }, uState: { value: 0 },
                    uColor1: { value: new THREE.Color(0xffd700) },
                    uColor2: { value: new THREE.Color(0xff8c00) }
                },
                vertexShader: vertexShader, fragmentShader: fragmentShader,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);
            
            // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            star.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            star.add(new THREE.PointLight(0xffffff, 5, 50));
            worldGroup.add(star);
        }

        // --- æ–°å¢ï¼šåˆ›å»ºå®ä½“è£…é¥°çƒ (InstancedMesh) ---
        function createOrnaments() {
            const count = CONFIG.ornamentCount;
            const half = Math.floor(count / 2);
            
            // 1. çº¢è‰²å“‘å…‰çƒ
            const redGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const redMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.4, metalness: 0.1 });
            redInstancedMesh = new THREE.InstancedMesh(redGeo, redMat, half);
            
            // 2. é‡‘è‰²äº®é¢çƒ
            const goldGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 0.9, emissive: 0x332200 });
            goldInstancedMesh = new THREE.InstancedMesh(goldGeo, goldMat, count - half);

            const dummy = new THREE.Object3D();

            for (let i = 0; i < count; i++) {
                // è®¡ç®—ä½ç½® (ç±»ä¼¼äºç²’å­ï¼Œä½†ç¨å¾®ç¨€ç–)
                const isRed = i < half;
                const angle = i * 0.5 + Math.random();
                const y = (i / count) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight;
                // è®©çƒä½“ç¨å¾®é™·åœ¨æ ‘é‡Œä¸€ç‚¹ï¼Œæˆ–è€…æµ®åœ¨è¡¨é¢
                const r = CONFIG.treeRadius * Math.pow(1 - progress, 0.9) + (Math.random() - 0.3);
                
                const tx = Math.cos(angle)*r;
                const ty = y;
                const tz = Math.sin(angle)*r;

                // æ•£å¼€ä½ç½®
                const sAngle = Math.random() * Math.PI * 2;
                const sRadius = Math.random() * CONFIG.scatterRadius * 0.8;
                const sx = Math.cos(sAngle)*sRadius;
                const sy = (Math.random()-0.5)*25;
                const sz = Math.sin(sAngle)*sRadius;

                // å­˜å‚¨æ•°æ®ä¾›åŠ¨ç”»ä½¿ç”¨
                ornamentData.push({
                    treePos: new THREE.Vector3(tx, ty, tz),
                    scatterPos: new THREE.Vector3(sx, sy, sz),
                    mesh: isRed ? redInstancedMesh : goldInstancedMesh,
                    index: isRed ? i : (i - half),
                    scale: Math.random() * 0.5 + 0.8
                });

                // åˆå§‹åŒ–ä½ç½®
                dummy.position.set(tx, ty, tz);
                dummy.scale.setScalar(ornamentData[i].scale);
                dummy.updateMatrix();
                
                if (isRed) redInstancedMesh.setMatrixAt(i, dummy.matrix);
                else goldInstancedMesh.setMatrixAt(i - half, dummy.matrix);
            }

            ornamentGroup.add(redInstancedMesh);
            ornamentGroup.add(goldInstancedMesh);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 12).forEach((file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const ar = texture.image.width / texture.image.height;
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(5 * ar, 5), // ç…§ç‰‡é»˜è®¤å¤§å°å¢åŠ 
                            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                        );
                        // ç²¾è‡´ç›¸æ¡†
                        const frame = new THREE.Mesh(
                            new THREE.BoxGeometry(5 * ar + 0.4, 5.4, 0.1),
                            new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8 })
                        );
                        frame.position.z = -0.06;
                        mesh.add(frame);

                        const angle = Math.random() * Math.PI * 2;
                        const y = (Math.random() - 0.5) * CONFIG.treeHeight * 0.6;
                        const r = CONFIG.treeRadius + 3;
                        mesh.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                        mesh.lookAt(0, y, 0);
                        
                        photoGroup.add(mesh);
                        photoParticles.push({ mesh: mesh, treePos: mesh.position.clone(), treeRot: mesh.rotation.clone(), index: photoParticles.length });
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        // --- MediaPipe & æ”¹è¿›çš„æ‰‹åŠ¿é€»è¾‘ ---

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start().then(() => { 
                gsap.to('#loader', { duration: 1, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); 
            });
        }

        function isFingerCurled(landmarks, tipIdx, pipIdx) {
             const wrist = landmarks[0];
             const tip = landmarks[tipIdx];
             const pip = landmarks[pipIdx];
             return Math.hypot(tip.x - wrist.x, tip.y - wrist.y) < Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
        }

        function onResults(results) {
            const bar = document.getElementById('force-bar');
            const status = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. å¼ æ‰‹å¹…åº¦ (Openness) - ä¼˜åŒ–ç®—æ³•
                const handSize = Math.hypot(landmarks[0].x - landmarks[9].x, landmarks[0].y - landmarks[9].y);
                let totalDist = 0;
                [8, 12, 16, 20].forEach(i => totalDist += Math.hypot(landmarks[i].x - landmarks[0].x, landmarks[i].y - landmarks[0].y));
                let openness = (totalDist / 4) / handSize; // æ¡æ‹³çº¦0.8ï¼Œå¼ å¼€çº¦1.8
                let forceVal = (openness - 1.0) / 0.8; 
                forceVal = Math.max(0, Math.min(1, forceVal)) * CONFIG.handSensitivity;
                bar.style.width = (forceVal * 100) + '%';

                // 2. æ‰‹æŒ‡çŠ¶æ€
                const indexOpen = !isFingerCurled(landmarks, 8, 6);
                const middleOpen = !isFingerCurled(landmarks, 12, 10);
                const ringCurled = isFingerCurled(landmarks, 16, 14);
                const pinkyCurled = isFingerCurled(landmarks, 20, 18);
                const thumbUp = landmarks[4].y < landmarks[3].y && landmarks[4].y < landmarks[8].y; // æ‹‡æŒ‡æœä¸Šä¸”é«˜äºé£ŸæŒ‡

                // --- çŠ¶æ€åˆ¤å®š ---
                
                // âœŠ æ¡æ‹³ (Fist) -> å¼ºåˆ¶å¤ä½
                if (forceVal < 0.15 && ringCurled && pinkyCurled) {
                    if (currentMode !== 'ANALOG') { exitToTree(); status.innerText = "RESET TREE"; }
                    return;
                }

                // âœŒï¸ å‰ªåˆ€æ‰‹/èƒœåˆ© (Victory) -> è¿›è‰ºå»Š
                // é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
                if (indexOpen && middleOpen && ringCurled && pinkyCurled && photoParticles.length > 0) {
                    if (currentMode !== 'CAROUSEL') { enterCarousel(); status.innerText = "OPEN GALLERY"; }
                    return;
                }

                // ğŸ‘ ç«–å¤§æ‹‡æŒ‡ (Thumb Up) -> æ”¾å¤§ç…§ç‰‡ (ä»…åœ¨è‰ºå»Šæ¨¡å¼)
                // é£ŸæŒ‡ä¸­æŒ‡æ— åæŒ‡å°æŒ‡éƒ½å¼¯æ›²ï¼Œæ‹‡æŒ‡ä¼¸ç›´
                if (!indexOpen && ringCurled && pinkyCurled && thumbUp) {
                    if (currentMode === 'CAROUSEL') { enterZoom(); status.innerText = "SHOWCASE"; }
                    return;
                }

                // ğŸ– çº¿æ€§æ§åˆ¶ (Analog)
                if (currentMode === 'ANALOG') {
                    targetExpansion = forceVal;
                    status.innerText = forceVal > 0.9 ? "FULL POWER" : "FORCE CONTROL";
                }
            } else {
                 if (currentMode === 'ANALOG') targetExpansion = 0;
            }
        }

        // --- åŠ¨ç”»çŠ¶æ€ ---

        function exitToTree() {
            currentMode = 'ANALOG';
            targetExpansion = 0;
            gsap.to(camera.position, { duration: 2, x: 0, y: 2, z: 48, ease: "power2.inOut" });
            photoParticles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 2, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z });
                gsap.to(p.mesh.rotation, { duration: 2, x: p.treeRot.x, y: p.treeRot.y, z: p.treeRot.z });
                gsap.to(p.mesh.scale, { duration: 1.5, x: 1, y: 1, z: 1 });
            });
        }

        function enterCarousel() {
            currentMode = 'CAROUSEL';
            targetExpansion = 1; 
            gsap.to(camera.position, { duration: 3, x: 0, y: 0, z: 40, ease: "power2.inOut" });
            const count = photoParticles.length;
            photoParticles.forEach((p, i) => {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * CONFIG.carouselRadius;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                gsap.to(p.mesh.position, { duration: 3, x: x, y: 0, z: z, ease: "back.out(0.8)" });
                gsap.to(p.mesh.rotation, { duration: 3, x: 0, y: Math.atan2(x, z) + Math.PI, z: 0 });
                gsap.to(p.mesh.scale, { duration: 3, x: 2, y: 2, z: 2 });
            });
        }

        function enterZoom() {
            currentMode = 'ZOOM';
            // æ‰¾åˆ°æ­£å¯¹å±å¹•çš„ç…§ç‰‡
            let bestP = null; let maxZ = -Infinity;
            photoParticles.forEach(p => {
                const angle = (p.index / photoParticles.length) * Math.PI * 2 + carouselAngleOffset;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                if(z > maxZ) { maxZ = z; bestP = p; }
            });

            if (bestP) {
                // å·¨å¹•ç‰¹å†™ï¼šæè¿‘è·ç¦» + å·¨å¤§æ¯”ä¾‹
                gsap.to(bestP.mesh.position, { duration: 1.5, x: 0, y: 0, z: 38, ease: "power3.out" }); // ç›¸æœºåœ¨48/40ï¼Œç‰©ä½“åœ¨38
                gsap.to(bestP.mesh.rotation, { duration: 1.5, x: 0, y: 0, z: 0 });
                gsap.to(bestP.mesh.scale, { duration: 1.5, x: 9, y: 9, z: 9 }); // 9å€æ”¾å¤§
                
                // å…¶ä»–ç…§ç‰‡é€€åå˜æš—
                photoParticles.forEach(p => {
                    if (p !== bestP) gsap.to(p.mesh.scale, { duration: 1, x: 0.1, y: 0.1, z: 0.1 });
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        const dummy = new THREE.Object3D();
        const v3 = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if (currentMode === 'ANALOG') {
                currentExpansion += (targetExpansion - currentExpansion) * 0.1;
            } else {
                currentExpansion += (1.0 - currentExpansion) * 0.05;
            }

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uState.value = currentExpansion;
            }

            // --- æ ¸å¿ƒï¼šæ›´æ–°å®ä½“çƒåŠ¨ç”» (æ‰‹åŠ¨æ’å€¼) ---
            if (redInstancedMesh && goldInstancedMesh) {
                ornamentData.forEach(data => {
                    // çº¿æ€§æ’å€¼ä½ç½®
                    v3.lerpVectors(data.treePos, data.scatterPos, currentExpansion);
                    
                    // æ•£å¼€æ—¶åŠ ä¸€ç‚¹å¤æ‚çš„å™ªç‚¹è¿åŠ¨
                    if (currentExpansion > 0.01) {
                        const noise = Math.sin(time + data.index) * currentExpansion * 2.0;
                        v3.y += noise; 
                    }

                    dummy.position.copy(v3);
                    dummy.scale.setScalar(data.scale * (1 + currentExpansion * 0.2)); // æ•£å¼€æ—¶ç¨å¾®å˜å¤§
                    
                    // æ—‹è½¬è·Ÿéš
                    if (currentMode === 'ANALOG') {
                        dummy.rotation.y = time * 0.5 + data.index;
                    }
                    
                    dummy.updateMatrix();
                    data.mesh.setMatrixAt(data.index, dummy.matrix);
                });
                redInstancedMesh.instanceMatrix.needsUpdate = true;
                goldInstancedMesh.instanceMatrix.needsUpdate = true;
            }

            // æ•´ä½“æ—‹è½¬
            if (currentMode === 'ANALOG') {
                worldGroup.rotation.y += 0.001 + currentExpansion * 0.002;
                // ç…§ç‰‡è·Ÿéš
                const exp = currentExpansion;
                photoParticles.forEach(p => {
                    p.mesh.position.lerpVectors(p.treePos, new THREE.Vector3(p.treePos.x*3, p.treePos.y*3, p.treePos.z*3), exp);
                    p.mesh.rotation.y = p.treeRot.y + exp * time;
                });
            } else if (currentMode === 'CAROUSEL') {
                carouselAngleOffset += 0.0005;
                const count = photoParticles.length;
                photoParticles.forEach((p, i) => {
                    const angle = (i / count) * Math.PI * 2 + carouselAngleOffset;
                    p.mesh.position.x = Math.cos(angle) * CONFIG.carouselRadius;
                    p.mesh.position.z = Math.sin(angle) * CONFIG.carouselRadius;
                    p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                });
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
