<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas Supreme: Gesture Art</title>
    <style>
        /* æç¹ä¸»ä¹‰æ·±è‰²èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: #020105; font-family: "Times New Roman", serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box;
            z-index: 10; color: #fff;
            background: radial-gradient(circle at center, transparent, rgba(0,0,0,0.8)); /* åŠ é‡æš—è§’ï¼Œçªå‡ºä¸­å¿ƒ */
        }
        
        h1 { 
            margin: 0 0 10px 0; font-weight: 400; text-transform: uppercase; 
            font-size: 26px; color: #f8e8c0; letter-spacing: 6px; text-align: center;
            text-shadow: 0 0 30px rgba(248, 232, 192, 0.7); /* æ›´å¼ºçš„æ ‡é¢˜è¾‰å…‰ */
        }

        #upload-btn {
            background: linear-gradient(45deg, rgba(212, 175, 55, 0.3), rgba(0,0,0,0.5));
            border: 1px solid rgba(248, 232, 192, 0.5); 
            color: #f8e8c0; padding: 10px 20px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; font-size: 11px; letter-spacing: 3px;
            transition: all 0.5s; display: inline-block; border-radius: 30px;
            margin: 0 auto; display: block; width: fit-content;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; align-items: center; justify-content: center;
            color: #d4af37; flex-direction: column; transition: opacity 1.5s ease-out;
        }

        /* è°ƒè¯•æ¡ */
        #force-bar-container {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 150px; height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px;
            overflow: hidden;
        }
        #force-bar {
            width: 0%; height: 100%; background: #f8e8c0; transition: width 0.2s ease-out;
            box-shadow: 0 0 10px #f8e8c0;
        }
        #status-text {
            text-align: center; font-size: 11px; color: rgba(248, 232, 192, 0.9); margin-top: 8px; letter-spacing: 2px;
            text-transform: uppercase; text-shadow: 0 0 10px rgba(248, 232, 192, 0.5);
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px; color: rgba(255,255,255,0.5);
            letter-spacing: 1px; line-height: 1.8;
        }
        .key { color: #f8e8c0; font-weight: bold; margin: 0 4px; font-size: 16px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <video id="video-input" playsinline webkit-playsinline style="transform: scaleX(-1);"></video>
    
    <div id="loader">
        <div style="letter-spacing: 5px; font-size: 16px; color: #f8e8c0; text-shadow: 0 0 20px #f8e8c0;">AWAKENING...</div>
    </div>

    <div id="ui-layer">
        <div>
            <h1>Merry Christmas</h1>
            <label for="file-input" id="upload-btn">Adorn Memories</label>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </div>
        
        <div>
            <div id="status-text">AWAITING GESTURE</div>
            <div id="force-bar-container"><div id="force-bar"></div></div>
        </div>

        <div id="guide">
            <span class="key">ğŸ–</span> å¼ æ‰‹å¹…åº¦æ§åˆ¶ Â· <span class="key">âœŠ</span> æ¡æ‹³å¤ä½<br>
            <span class="key">âœŒï¸</span> èƒœåˆ©æ‰‹åŠ¿è¿›è‰ºå»Š Â· <span class="key">ğŸ‘†</span> å•æŒ‡æŒ‡å‘æ”¾å¤§
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 6000, // æç¹ä¸»ä¹‰ï¼šå¢åŠ ç²’å­
            treeHeight: 38,
            treeRadius: 13,
            scatterRadius: 65,
            carouselRadius: 22, // è‰ºå»ŠåŠå¾„æ›´å¤§ï¼Œæ›´æ°”æ´¾
            handSensitivity: 1.0
        };

        let scene, camera, renderer, composer;
        let particleSystem, photoGroup;
        let photoParticles = [];
        
        let currentMode = 'ANALOG'; // 'ANALOG', 'CAROUSEL', 'ZOOM'
        let targetExpansion = 0;    
        let currentExpansion = 0;   
        
        let carouselAngleOffset = 0;

        const worldGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        worldGroup.add(photoGroup);

        // --- Shader (ä¼˜åŒ–è‰²å½©å’Œé—ªçƒ) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uState;
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aRandom;
            attribute float aSize;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                vRandom = aRandom;
                vec3 pos = mix(aTreePos, aScatterPos, uState);
                vPos = pos;
                
                // æ›´å¤æ‚çš„å™ªç‚¹è¿åŠ¨
                float noiseAmp = 0.08 + 0.25 * uState;
                float noise = sin(uTime * 1.2 + aRandom * 10.0) * noiseAmp;
                float noise2 = cos(uTime * 1.5 + aRandom * 12.0) * noiseAmp;
                pos.x += noise; 
                pos.y += noise * 0.4 + uState * 2.0; // æ•£å¼€æ—¶ç¨å¾®ä¸Šå‡
                pos.z += noise2;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                float sizeState = 1.0 + uState * 0.8; // æ•£å¼€æ—¶ç²’å­å˜å¤§æ›´å¤š
                float twinkle = sin(uTime * 2.5 + aRandom * 30.0) * 0.5 + 0.5;
                gl_PointSize = aSize * sizeState * (250.0 / -mvPosition.z) * (0.3 + 0.7 * twinkle);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            varying float vRandom;
            varying vec3 vPos;

            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;
                // æ›´é”åˆ©çš„æ ¸å¿ƒï¼Œæ›´æŸ”å’Œçš„è¾¹ç¼˜
                float strength = pow(1.0 - dist * 2.0, 3.0);
                
                // æ›´ä¸°å¯Œçš„é‡‘è‰²åˆ°æš–çº¢æ¸å˜
                vec3 color = mix(uColor1, uColor2, vRandom);
                color = mix(color, vec3(1.0, 0.9, 0.5), strength * 0.5); // æ ¸å¿ƒæ›´ç™½äº®
                
                // åº•éƒ¨åçº¢å…‰æ™•
                color += vec3(0.3, 0.1, 0.0) * (smoothstep(-20.0, 10.0, vPos.y) * 0.5);
                
                gl_FragColor = vec4(color * strength * 2.5, strength); // æ•´ä½“äº®åº¦æå‡
            }
        `;

        async function init() {
            scene = new THREE.Scene();
            // æ›´æ·±é‚ƒçš„é»‘é‡‘é›¾æ°”
            scene.fog = new THREE.FogExp2(0x050200, 0.004);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 3, 50);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; // æ›å…‰åº¦æå‡
            document.body.appendChild(renderer.domElement);

            scene.add(worldGroup);

            const mainLight = new THREE.PointLight(0xffd700, 8, 120);
            mainLight.position.set(0, 20, 10);
            worldGroup.add(mainLight);

            // æè‡´è¾‰å…‰ï¼šåŠå¾„æ›´å¤§ï¼Œå¼ºåº¦æ›´é«˜
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.9, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            setupMediaPipe();
            animate();
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const treePositions = new Float32Array(count * 3);
            const scatterPositions = new Float32Array(count * 3);
            const randoms = new Float32Array(count);
            const sizes = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                // Tree: æ›´è‡ªç„¶çš„èºæ—‹å †ç§¯
                const angle = i * 0.15 + Math.random() * 0.5;
                const y = (i / count) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const progress = (y + (CONFIG.treeHeight / 2)) / CONFIG.treeHeight; 
                const radius = CONFIG.treeRadius * Math.pow(1 - progress, 1.2) + Math.random()*1.5;
                treePositions[i*3] = Math.cos(angle) * radius;
                treePositions[i*3+1] = y;
                treePositions[i*3+2] = Math.sin(angle) * radius;

                // Scatter: æ‰å¹³çš„æ˜Ÿç³»ç›˜çŠ¶
                const sAngle = Math.random() * Math.PI * 2;
                const sRadius = Math.random() * CONFIG.scatterRadius * (0.5 + 0.5*Math.random());
                scatterPositions[i*3] = Math.cos(sAngle) * sRadius;
                scatterPositions[i*3+1] = (Math.random() - 0.5) * 25 * (1-sRadius/CONFIG.scatterRadius); // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                scatterPositions[i*3+2] = Math.sin(sAngle) * sRadius;

                randoms[i] = Math.random();
                sizes[i] = Math.random() * 2.5 + 0.8;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aTreePos', new THREE.BufferAttribute(treePositions, 3));
            geometry.setAttribute('aScatterPos', new THREE.BufferAttribute(scatterPositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uState: { value: 0 },
                    uColor1: { value: new THREE.Color(0xf8e8c0) }, // é¦™æ§Ÿé‡‘
                    uColor2: { value: new THREE.Color(0xff6f00) }  // æ·±é‡‘æ©˜
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            worldGroup.add(particleSystem);
            
            // é¡¶éƒ¨ä¼¯åˆ©æ’ä¹‹æ˜Ÿ
            const starGeo = new THREE.SphereGeometry(1.2, 16, 16);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.treeHeight/2 + 2.5, 0);
            // å·¨å¤§çš„æ˜ŸèŠ’å…‰æ™•
            const starLight = new THREE.PointLight(0xffffff, 5, 60);
            star.add(starLight);
            worldGroup.add(star);
        }

        function handleUpload(event) {
            const files = event.target.files; if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).slice(0, 20).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.load(e.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const ar = texture.image.width / texture.image.height;
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(4.5 * ar, 4.5), // ç…§ç‰‡æ›´å¤§
                            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
                        );
                        // æ›´ç²¾è‡´çš„é‡‘æ¡†
                        const frame = new THREE.Mesh(
                            new THREE.BoxGeometry(4.5 * ar + 0.3, 4.8, 0.2),
                            new THREE.MeshStandardMaterial({ color: 0xf8e8c0, metalness: 1.0, roughness: 0.1 })
                        );
                        frame.position.z = -0.11;
                        mesh.add(frame);

                        const angle = Math.random() * Math.PI * 2;
                        const y = (Math.random() - 0.5) * CONFIG.treeHeight * 0.8;
                        const r = CONFIG.treeRadius + 3;
                        mesh.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                        mesh.lookAt(0, y, 0);
                        
                        photoGroup.add(mesh);
                        photoParticles.push({ mesh: mesh, treePos: mesh.position.clone(), treeRot: mesh.rotation.clone(), index: photoParticles.length });
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        // --- MediaPipe & æ–°æ‰‹åŠ¿é€»è¾‘ ---

        function setupMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start().then(() => { 
                gsap.to('#loader', { duration: 1.2, opacity: 0, onComplete: () => document.getElementById('loader').style.display = 'none' }); 
            });
        }

        let lastHandDetectedTime = 0;

        // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²ï¼ˆæŒ‡å°–åˆ°æ‰‹è…•è·ç¦» < æŒ‡å…³èŠ‚åˆ°æ‰‹è…•è·ç¦»ï¼‰
        function isFingerBent(landmarks, tipIdx, pipIdx) {
            const wrist = landmarks[0];
            const tip = landmarks[tipIdx];
            const pip = landmarks[pipIdx];
            return Math.hypot(tip.x - wrist.x, tip.y - wrist.y) < Math.hypot(pip.x - wrist.x, pip.y - wrist.y) * 0.9; // 0.9ç³»æ•°å¢åŠ å®¹é”™
        }

        function onResults(results) {
            const now = performance.now();
            const bar = document.getElementById('force-bar');
            const status = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                lastHandDetectedTime = now;
                const landmarks = results.multiHandLandmarks[0];
                
                // --- 1. è®¡ç®—çœŸå®çš„å¼ æ‰‹å¹…åº¦ (ä¿®å¤ç‰ˆ) ---
                // ä½¿ç”¨æ‰‹æŒå¤§å°(è…•åˆ°ä¸­æŒ‡æ ¹)ä½œä¸ºå‚è€ƒå°º
                const handScale = Math.hypot(landmarks[9].x - landmarks[0].x, landmarks[9].y - landmarks[0].y);
                // è®¡ç®—å››æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                let totalTipDist = 0;
                [8, 12, 16, 20].forEach(i => totalTipDist += Math.hypot(landmarks[i].x - landmarks[0].x, landmarks[i].y - landmarks[0].y));
                const avgTipDist = totalTipDist / 4;
                // è®¡ç®—ç›¸å¯¹å¼ å¼€æ¯”ä¾‹ (ç»éªŒå€¼ï¼šæ¡æ‹³çº¦1.0å€æ‰‹æŒé•¿ï¼Œå¼ å¼€çº¦2.2å€)
                let rawOpenness = avgTipDist / handScale; 
                // æ˜ å°„åˆ° 0~1 èŒƒå›´
                let openness = (rawOpenness - 1.1) / 1.1; 
                openness = Math.max(0, Math.min(1, openness)) * CONFIG.handSensitivity;
                bar.style.width = (openness * 100) + '%';

                // --- 2. æ‰‹åŠ¿åˆ†ç±» ---
                const indexBent = isFingerBent(landmarks, 8, 6);
                const middleBent = isFingerBent(landmarks, 12, 10);
                const ringBent = isFingerBent(landmarks, 16, 14);
                const pinkyBent = isFingerBent(landmarks, 20, 18);

                // âœŠ æ¡æ‹³
                const isFist = indexBent && middleBent && ringBent && pinkyBent && openness < 0.2;
                // âœŒï¸ èƒœåˆ© (é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²)
                const isVictory = !indexBent && !middleBent && ringBent && pinkyBent;
                // ğŸ‘† æŒ‡å‘ (ä»…é£ŸæŒ‡ä¼¸ç›´)
                const isPointing = !indexBent && middleBent && ringBent && pinkyBent;

                // --- çŠ¶æ€æœºé€»è¾‘ ---

                // ä¼˜å…ˆçº§ 1: æ¡æ‹³ -> å¼ºåˆ¶å¤ä½
                if (isFist) {
                    if (currentMode !== 'ANALOG') { exitToTree(); status.innerText = "RETURNING TO TREE"; }
                    return;
                }

                // ä¼˜å…ˆçº§ 2: èƒœåˆ©æ‰‹åŠ¿ -> è¿›å…¥è‰ºå»Š
                if (isVictory && photoParticles.length > 0) {
                    if (currentMode !== 'CAROUSEL') { enterCarousel(); status.innerText = "ENTERING GALLERY"; }
                    return;
                }

                // ä¼˜å…ˆçº§ 3: æŒ‡å‘æ‰‹åŠ¿ -> æ”¾å¤§ç…§ç‰‡ (ä»…åœ¨è‰ºå»Šæ¨¡å¼ä¸‹)
                if (currentMode === 'CAROUSEL' && isPointing) {
                    enterZoom();
                    status.innerText = "ZOOMING IN";
                    return;
                }

                // ä¼˜å…ˆçº§ 4: çº¿æ€§æ§åˆ¶ (ä»…åœ¨åŸºç¡€æ¨¡å¼ä¸‹)
                if (currentMode === 'ANALOG') {
                    targetExpansion = openness;
                    status.innerText = openness > 0.9 ? "FULL BLOOM" : (openness < 0.1 ? "TREE STABLE" : "CONTROLLING...");
                }

            } else {
                if (now - lastHandDetectedTime > 1500) {
                    if (currentMode === 'ANALOG') targetExpansion = 0;
                    status.innerText = "AWAITING GESTURE";
                    bar.style.width = '0%';
                }
            }
        }

        // --- çŠ¶æ€è½¬æ¢åŠ¨ç”» (æç¹ä¸»ä¹‰ä¼˜åŒ–) ---

        function exitToTree() {
            currentMode = 'ANALOG';
            targetExpansion = 0;
            gsap.to(camera.position, { duration: 2.5, x: 0, y: 3, z: 50, ease: "power3.inOut" });
            photoParticles.forEach(p => {
                gsap.to(p.mesh.position, { duration: 2.5, x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, ease: "back.out(0.8)" });
                gsap.to(p.mesh.rotation, { duration: 2.5, x: p.treeRot.x, y: p.treeRot.y, z: p.treeRot.z });
                gsap.to(p.mesh.scale, { duration: 2, x: 1, y: 1, z: 1 });
            });
        }

        function enterCarousel() {
            currentMode = 'CAROUSEL';
            targetExpansion = 1; // èƒŒæ™¯å®Œå…¨æ•£å¼€
            // ç¼“æ…¢ã€ä¼˜é›…çš„ç›¸æœºç§»åŠ¨
            gsap.to(camera.position, { duration: 4, x: 0, y: 0, z: 45, ease: "power2.inOut" });
            
            const count = photoParticles.length;
            photoParticles.forEach((p, i) => {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * CONFIG.carouselRadius;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                // ç…§ç‰‡ç¼“æ…¢é£å…¥åœ†ç¯å¹¶æ”¾å¤§
                gsap.to(p.mesh.position, { duration: 4, x: x, y: 0, z: z, ease: "power3.out" });
                gsap.to(p.mesh.rotation, { duration: 4, x: 0, y: Math.atan2(x, z) + Math.PI, z: 0, ease: "power2.inOut" });
                gsap.to(p.mesh.scale, { duration: 3, delay: 0.5, x: 2, y: 2, z: 2, ease: "back.out(1)" });
            });
        }

        function enterZoom() {
            currentMode = 'ZOOM';
            // æ‰¾åˆ°æ­£å¯¹å±å¹•çš„ç…§ç‰‡
            let bestP = null; let maxZ = -Infinity;
            photoParticles.forEach(p => {
                const angle = (p.index / photoParticles.length) * Math.PI * 2 + carouselAngleOffset;
                const z = Math.sin(angle) * CONFIG.carouselRadius;
                if(z > maxZ) { maxZ = z; bestP = p; }
            });

            if (bestP) {
                // è¶…çº§æ”¾å¤§ (7å€)
                gsap.to(bestP.mesh.position, { duration: 1.2, x: 0, y: 0, z: 38, ease: "power4.out" });
                gsap.to(bestP.mesh.rotation, { duration: 1.2, x: 0, y: 0, z: 0 });
                gsap.to(bestP.mesh.scale, { duration: 1.2, x: 7, y: 7, z: 7 }); 
                // å…¶ä»–ç…§ç‰‡é€€åå˜æš—
                photoParticles.forEach(p => {
                   if(p !== bestP) gsap.to(p.mesh.scale, { duration: 1, x: 1, y: 1, z: 1 });
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // å¹³æ»‘æ’å€¼ï¼Œæ‰‹åŠ¿æ§åˆ¶æ›´è·Ÿæ‰‹
            if (currentMode === 'ANALOG') {
                currentExpansion += (targetExpansion - currentExpansion) * 0.12;
            } else {
                currentExpansion += (1.0 - currentExpansion) * 0.08;
            }

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uState.value = currentExpansion;
            }

            if (currentMode === 'ANALOG') {
                worldGroup.rotation.y += 0.0015 + (currentExpansion * 0.003);
                // ç…§ç‰‡è·Ÿéšæ’å€¼
                const exp = currentExpansion;
                photoParticles.forEach(p => {
                    p.mesh.position.x = p.treePos.x * (1+exp*2.5);
                    p.mesh.position.y = p.treePos.y * (1+exp*0.5) + Math.sin(time+p.index)*exp;
                    p.mesh.position.z = p.treePos.z * (1+exp*2.5);
                    p.mesh.rotation.y = p.treeRot.y + exp * time * 0.5;
                });

            } else if (currentMode === 'CAROUSEL') {
                // ææ…¢é€Ÿè‡ªåŠ¨æ—‹è½¬
                carouselAngleOffset += 0.0008;
                const count = photoParticles.length;
                photoParticles.forEach((p, i) => {
                    const angle = (i / count) * Math.PI * 2 + carouselAngleOffset;
                    p.mesh.position.x = Math.cos(angle) * CONFIG.carouselRadius;
                    p.mesh.position.z = Math.sin(angle) * CONFIG.carouselRadius;
                    p.mesh.rotation.y = Math.atan2(p.mesh.position.x, p.mesh.position.z) + Math.PI;
                });
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
